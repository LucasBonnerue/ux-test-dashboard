<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UX-Test Dashboard</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
  <style>
    :root {
      --primary: #0066cc;
      --secondary: #6c757d;
      --success: #28a745;
      --warning: #ffc107;
      --danger: #dc3545;
      --info: #17a2b8;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8f9fa;
      margin: 0;
      padding: 0;
    }
    
    .dashboard-header {
      background-color: #343a40;
      color: white;
      padding: 20px 0;
      margin-bottom: 30px;
    }
    
    .card {
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      transition: transform 0.3s;
    }
    
    .card:hover {
      transform: translateY(-5px);
    }
    
    .card-header {
      font-weight: 600;
      border-bottom: 1px solid #eee;
    }
    
    .stat-card {
      text-align: center;
      padding: 15px;
    }
    
    .stat-card .number {
      font-size: 2.5rem;
      font-weight: 700;
      margin: 10px 0;
    }
    
    .stat-card .label {
      font-size: 0.9rem;
      color: #6c757d;
    }
    
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    .issue-table {
      font-size: 0.9rem;
    }
    
    .issue-table th {
      background-color: #f8f9fa;
    }
    
    .issue-critical {
      color: var(--danger);
      font-weight: 700;
    }
    
    .issue-high {
      color: var(--warning);
      font-weight: 600;
    }
    
    .issue-medium {
      color: var(--info);
    }
    
    .issue-low {
      color: var(--secondary);
    }
    
    /* Erfolgsraten Styling */
    .success-high {
      background-color: rgba(40, 167, 69, 0.1);
    }
    
    .success-medium {
      background-color: rgba(255, 193, 7, 0.1);
    }
    
    .success-low {
      background-color: rgba(220, 53, 69, 0.1);
    }
    
    .trend-icon {
      font-size: 1.2em;
      margin-left: 5px;
    }
    
    .trend-icon.improving {
      color: var(--success);
    }
    
    .trend-icon.declining {
      color: var(--danger);
    }
    
    .trend-icon.stable {
      color: var(--info);
    }
    
    /* Flakiness Styling */
    .high-flakiness {
      background-color: rgba(220, 53, 69, 0.1);
    }
    
    .medium-flakiness {
      background-color: rgba(255, 193, 7, 0.1);
    }
    
    .low-flakiness {
      background-color: rgba(40, 167, 69, 0.1);
    }
    
    #threshold-value {
      font-weight: bold;
      margin-top: 5px;
    }
    
    .template-selector {
      background-color: white;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .recommendation-item {
      padding: 10px;
      border-left: 3px solid var(--primary);
      margin-bottom: 10px;
      background-color: rgba(0, 102, 204, 0.05);
    }
    
    .footer {
      background-color: #343a40;
      color: rgba(255,255,255,0.7);
      padding: 20px 0;
      margin-top: 40px;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header class="dashboard-header">
    <div class="container">
      <div class="row align-items-center">
        <div class="col-md-8">
          <h1>UX-Test Dashboard</h1>
          <p class="lead">Dashboard zur Analyse und Visualisierung von UX-Test-Ergebnissen</p>
        </div>
        <div class="col-md-4 text-end">
          <button id="refreshBtn" class="btn btn-outline-light me-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
              <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
              <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
            </svg>
            Aktualisieren
          </button>
          <button id="run-tests-btn" class="btn btn-primary me-2 tests-ausfuehren-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
              <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
            </svg>
            Tests ausführen
          </button>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <!-- Navigation Tabs -->
    <ul class="nav nav-tabs mb-4" id="dashboard-tabs" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="ux-tab" data-bs-toggle="tab" data-bs-target="#ux-tests" type="button" role="tab" aria-controls="ux-tests" aria-selected="true">UX Tests</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="playwright-tab" data-bs-toggle="tab" data-bs-target="#playwright-tests" type="button" role="tab" aria-controls="playwright-tests" aria-selected="false">Playwright Tests</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="insights-tab" data-bs-toggle="tab" data-bs-target="#test-insights" type="button" role="tab" aria-controls="test-insights" aria-selected="false">Test Insights</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="test-analysis-tab" data-bs-toggle="tab" data-bs-target="#test-analysis" type="button" role="tab" aria-controls="test-analysis" aria-selected="false">Test Analyse</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="metrics-tab" data-bs-toggle="tab" data-bs-target="#metrics-content" type="button" role="tab" aria-controls="metrics-content" aria-selected="false">Test Metriken</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="logs-tab" data-bs-toggle="tab" data-bs-target="#system-logs" type="button" role="tab" aria-controls="system-logs" aria-selected="false">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-journal-text me-1" viewBox="0 0 16 16">
            <path d="M5 10.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>
            <path d="M3 0h10a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2v-12a2 2 0 0 1 2-2zm0 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H3z"/>
          </svg>
          Logs
        </button>
      </li>
    </ul>
    
    <!-- Tab Content -->
    <div class="tab-content" id="dashboard-tab-content">
      <!-- UX Tests Tab -->
      <div class="tab-pane fade show active" id="ux-tests" role="tabpanel" aria-labelledby="ux-tab">
        <div class="template-selector">
          <div class="row align-items-center">
            <div class="col-md-4">
              <label for="templateSelect" class="form-label">Template auswählen:</label>
              <select id="templateSelect" class="form-select">
                <option value="all">Alle Templates</option>
                <option value="base">Basis-Template</option>
                <option value="accessibility">Barrierefreiheits-Probleme</option>
                <option value="responsive">Responsive-Design-Probleme</option>
                <option value="performance">Performance-Probleme</option>
                <option value="navigation">Navigationsprobleme</option>
              </select>
            </div>
            <div class="col-md-4">
              <label for="timeRangeSelect" class="form-label">Zeitraum:</label>
              <select id="timeRangeSelect" class="form-select">
                <option value="today">Heute</option>
                <option value="week" selected>Letzte Woche</option>
                <option value="month">Letzter Monat</option>
                <option value="all">Alle</option>
              </select>
            </div>
            <div class="col-md-4 d-flex align-items-end">
              <button class="btn btn-primary" id="applyFilters">Filter anwenden</button>
            </div>
          </div>
        </div>
      
      <!-- Playwright Tests Tab -->
      </div>
      <div class="tab-pane fade" id="playwright-tests" role="tabpanel" aria-labelledby="playwright-tab">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Verfügbare Playwright Tests</h5>
            <button class="btn btn-success tests-ausfuehren-btn" id="run-playwright-tests-btn">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
              </svg>
              Tests ausführen
            </button>
          </div>
          <div class="card-body">
            <div class="table-responsive">
              <table class="table table-striped table-hover" id="playwright-tests-table">
                <thead>
                  <tr>
                    <th><input type="checkbox" id="select-all-tests" class="form-check-input"></th>
                    <th>Testdatei</th>
                    <th>Beschreibung</th>
                    <th>Aktionen</th>
                  </tr>
                </thead>
                <tbody id="playwright-tests-table-body">
                  <tr>
                    <td colspan="4" class="text-center">Lade Tests...</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        
        <div class="card mt-4">
          <div class="card-header">
            <h5>Test-Ergebnisse</h5>
          </div>
          <div class="card-body">
            <!-- Ergebnis-Tabs -->
            <ul class="nav nav-tabs mb-3" id="results-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="current-tab" data-bs-toggle="tab" data-bs-target="#current-results" 
                  type="button" role="tab" aria-controls="current-results" aria-selected="true">Aktuelle Ergebnisse</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="results-tab" data-bs-toggle="tab" data-bs-target="#saved-results" 
                  type="button" role="tab" aria-controls="saved-results" aria-selected="false">Gespeicherte Ergebnisse</button>
              </li>
            </ul>
            
            <!-- Tab-Inhalt für Ergebnisse -->
            <div class="tab-content" id="results-tab-content">
              <!-- Tab: Aktuelle Ergebnisse -->
              <div class="tab-pane fade show active" id="current-results" role="tabpanel" aria-labelledby="current-tab">
                <div id="playwright-results">
                  <div class="alert alert-info">Keine aktuellen Testergebnisse verfügbar. Führen Sie Tests aus, um Ergebnisse zu sehen.</div>
                </div>
                <pre id="playwright-output" class="bg-dark text-light p-3 mt-3" style="max-height: 300px; overflow-y: auto; display: none;"></pre>
                <div class="mt-3 d-flex justify-content-end">
                  <button id="save-current-results" class="btn btn-primary" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16">
                      <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L7.5 9.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/>
                    </svg>
                    Ergebnis speichern
                  </button>
                </div>
              </div>
              
              <!-- Tab: Gespeicherte Ergebnisse -->
              <div class="tab-pane fade" id="saved-results" role="tabpanel" aria-labelledby="results-tab">
                <div id="playwright-status" class="alert alert-info">Gespeicherte Testergebnisse werden geladen...</div>
                
                <!-- Liste der gespeicherten Ergebnisse -->
                <div id="playwright-results-list"></div>
                
                <!-- Detail-Ansicht für ein einzelnes Ergebnis -->
                <div id="playwright-result-detail" style="display: none;"></div>
                
                <!-- Vergleichs-Ansicht für zwei Ergebnisse -->
                <div id="playwright-result-comparison" style="display: none;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Test Insights Tab -->
      <div class="tab-pane fade" id="test-insights" role="tabpanel" aria-labelledby="insights-tab">
        <div class="row">
          <div class="col-md-12 mb-4">
            <h3>Test Insights</h3>
            <p>Visualisierung und Analyse von Testergebnissen.</p>
          </div>
        </div>
      </div>
      
      <!-- Test-Metriken Tab -->
      <div class="tab-pane fade" id="metrics-content" role="tabpanel" aria-labelledby="metrics-tab">
        <div class="container-fluid">
          <!-- Erfolgsraten- und Flakiness-Daten Filteroptionen -->
          <div class="row mb-4">
            <div class="col-12 col-lg-6">
              <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                  <span>Erfolgsraten-Filter</span>
                </div>
                <div class="card-body">
                  <div class="row">
                    <div class="col-md-6">
                      <label for="date-range-select" class="form-label">Zeitraum:</label>
                      <select class="form-select" id="date-range-select">
                        <option value="7d" selected>Letzte 7 Tage</option>
                        <option value="30d">Letzte 30 Tage</option>
                        <option value="90d">Letzte 90 Tage</option>
                        <option value="all">Alle Daten</option>
                      </select>
                    </div>
                    <div class="col-md-6">
                      <label for="test-type-filter" class="form-label">Test-Typ:</label>
                      <select class="form-select" id="test-type-filter">
                        <option value="all" selected>Alle Tests</option>
                        <option value="ui">UI-Tests</option>
                        <option value="api">API-Tests</option>
                        <option value="e2e">End-to-End Tests</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-12 col-lg-6">
              <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                  <span>Flakiness-Filter</span>
                </div>
                <div class="card-body">
                  <div class="row">
                    <div class="col-md-6">
                      <label for="flakiness-days-select" class="form-label">Zeitraum für Flakiness:</label>
                      <select class="form-select" id="flakiness-days-select">
                        <option value="7" selected>Letzte 7 Tage</option>
                        <option value="14">Letzte 14 Tage</option>
                        <option value="30">Letzte 30 Tage</option>
                        <option value="60">Letzte 60 Tage</option>
                      </select>
                    </div>
                    <div class="col-md-6">
                      <label for="flakiness-threshold" class="form-label">Schwellenwert:</label>
                      <input type="range" class="form-range" min="0" max="100" step="5" value="30" id="flakiness-threshold">
                      <div class="text-center" id="threshold-value">30%</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Erfolgsraten-Sektion -->
          <div class="row">
            <div class="col-12 col-lg-6 mb-4">
              <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                  <span>Test-Erfolgsraten</span>
                  <button class="btn btn-sm btn-outline-secondary refresh-btn" onclick="window.SuccessRateView.loadSuccessRates()">
                    <i class="bi bi-arrow-repeat"></i> Aktualisieren
                  </button>
                </div>
                <div class="card-body">
                  <!-- Ladeanzeige -->
                  <div id="metrics-loading" class="text-center" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                      <span class="visually-hidden">Lädt...</span>
                    </div>
                    <p>Lade Erfolgsraten...</p>
                  </div>
                  
                  <!-- Fehlermeldung -->
                  <div id="metrics-error" class="alert alert-danger" style="display: none;"></div>
                  
                  <!-- Erfolgsraten-Tabelle -->
                  <div id="success-rate-container">
                    <div class="alert alert-info">Bitte warten... Erfolgsraten werden geladen.</div>
                  </div>
                  
                  <!-- Erfolgsraten-Trend Chart -->
                  <div class="mt-4">
                    <h5>Erfolgsraten-Trend</h5>
                    <canvas id="success-trend-chart" height="250"></canvas>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Flakiness-Sektion -->
            <div class="col-12 col-lg-6 mb-4">
              <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                  <span>Test-Instabilität (Flakiness)</span>
                  <button class="btn btn-sm btn-outline-secondary refresh-btn" onclick="window.FlakinessView.loadFlakinessReport()">
                    <i class="bi bi-arrow-repeat"></i> Aktualisieren
                  </button>
                </div>
                <div class="card-body">
                  <!-- Ladeanzeige -->
                  <div id="flakiness-loading" class="text-center" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                      <span class="visually-hidden">Lädt...</span>
                    </div>
                    <p>Lade Flakiness-Daten...</p>
                  </div>
                  
                  <!-- Fehlermeldung -->
                  <div id="flakiness-error" class="alert alert-danger" style="display: none;"></div>
                  
                  <!-- Flakiness-Übersicht -->
                  <div id="flakiness-container">
                    <div class="alert alert-info">Bitte warten... Flakiness-Daten werden geladen.</div>
                  </div>
                  
                  <!-- Flakiness-Verteilung Chart -->
                  <div class="mt-4">
                    <h5>Flakiness-Verteilung</h5>
                    <canvas id="flakiness-chart" height="250"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Instabile Tests Liste -->
          <div class="row">
            <div class="col-12">
              <div class="card mb-4">
                <div class="card-header">Instabile Tests (Flaky Tests)</div>
                <div class="card-body">
                  <div id="flaky-tests-container">
                    <div class="alert alert-info">Bitte warten... Daten werden geladen.</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- System-Logs Tab -->
      <div class="tab-pane fade" id="system-logs" role="tabpanel" aria-labelledby="logs-tab">
        <div class="row mb-4">
          <div class="col-12">
            <div class="card">
              <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">System-Logs</h5>
                <div>
                  <button id="refresh-logs-btn" class="btn btn-outline-primary btn-sm me-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                      <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                    </svg>
                    Aktualisieren
                  </button>
                  <button id="clear-logs-btn" class="btn btn-outline-danger btn-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                      <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                      <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                    Logs löschen
                  </button>
                </div>
              </div>
              <div class="card-body">
                <div class="row mb-3">
                  <div class="col-md-6">
                    <div class="input-group">
                      <input type="text" id="log-search" class="form-control" placeholder="Logs durchsuchen...">
                      <button class="btn btn-outline-secondary" type="button" id="search-logs-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                        </svg>
                      </button>
                    </div>
                  </div>
                  <div class="col-md-6">
                    <div class="d-flex justify-content-end">
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-debug" checked>
                        <label class="form-check-label" for="show-debug">DEBUG</label>
                      </div>
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-info" checked>
                        <label class="form-check-label" for="show-info">INFO</label>
                      </div>
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-warn" checked>
                        <label class="form-check-label" for="show-warn">WARN</label>
                      </div>
                      <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-error" checked>
                        <label class="form-check-label" for="show-error">ERROR</label>
                      </div>
                      <div class="form-check form-check-inline">
                        <select id="component-filter" class="form-select form-select-sm">
                          <option value="all">Alle Komponenten</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="log-container bg-dark text-light p-3" style="height: 500px; overflow-y: auto; font-family: monospace;">
                  <div id="log-entries"></div>
                </div>
              </div>
              <div class="card-footer d-flex justify-content-between align-items-center">
                <div>
                  <span id="log-count" class="badge bg-secondary">0</span> Einträge
                </div>
                <div>
                  <button id="download-logs-btn" class="btn btn-sm btn-outline-secondary">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                      <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                      <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                    </svg>
                    Logs herunterladen
                  </button>
                  <div class="form-check form-check-inline ms-2">
                    <input class="form-check-input" type="checkbox" id="auto-refresh" checked>
                    <label class="form-check-label" for="auto-refresh">Auto-Refresh</label>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Test-Analyse Tab -->
      <div class="tab-pane fade" id="test-analysis" role="tabpanel" aria-labelledby="test-analysis-tab">
        <div class="row mb-4">
          <div class="col-12">
            <div class="card">
              <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Test-Metadaten & Analyse</h5>
                <button id="run-analysis-btn" class="btn btn-primary">
                  <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true" id="analysis-spinner"></span>
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                    <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                  </svg>
                  Tests analysieren
                </button>
              </div>
              <div class="card-body">
                <div class="alert alert-info">
                  <strong>Hinweis:</strong> Die Test-Analyse durchsucht alle Playwright-Tests nach Metadaten wie Selektoren, Assertions und Testabdeckung.
                </div>
                <div id="analysis-status" class="mb-4"></div>
                
                <!-- Analyse Tab Navigation -->
                <ul class="nav nav-tabs" id="analysis-tab-list" role="tablist">
                  <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis-content" type="button" role="tab" aria-controls="analysis-content" aria-selected="true">Analyse</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="quality-tab" data-bs-toggle="tab" data-bs-target="#quality-content" type="button" role="tab" aria-controls="quality-content" aria-selected="false">Qualität</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="coverage-tab" data-bs-toggle="tab" data-bs-target="#coverage-content" type="button" role="tab" aria-controls="coverage-content" aria-selected="false">Abdeckung</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="decision-tab" data-bs-toggle="tab" data-bs-target="#decision-content" type="button" role="tab" aria-controls="decision-content" aria-selected="false">Entscheidungsmatrix</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="consolidate-tab" data-bs-toggle="tab" data-bs-target="#consolidate-content" type="button" role="tab" aria-controls="consolidate-content" aria-selected="false">Testkonsolidierung</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="portfolio-tab" data-bs-toggle="tab" data-bs-target="#portfolio-content" type="button" role="tab" aria-controls="portfolio-content" aria-selected="false">Test-Portfolio</button>
                  </li>
                </ul>
                
                <!-- Analyse Tab-Inhalte -->
                <div class="tab-content" id="analysis-tab-content">
                  <!-- Test-Metadaten Tab -->
                  <div class="tab-pane fade show active" id="metadata-content" role="tabpanel" aria-labelledby="metadata-tab">
                    <div class="row mb-3">
                      <div class="col-md-4">
                        <div class="input-group">
                          <input type="text" class="form-control" id="metadata-search" placeholder="Tests filtern...">
                          <button class="btn btn-outline-secondary" type="button" id="metadata-filter-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-funnel" viewBox="0 0 16 16">
                              <path d="M1.5 1.5A.5.5 0 0 1 2 1h12a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.128.334L10 8.692V13.5a.5.5 0 0 1-.342.474l-3 1A.5.5 0 0 1 6 14.5V8.692L1.628 3.834A.5.5 0 0 1 1.5 3.5v-2zm1 .5v1.308l4.372 4.858A.5.5 0 0 1 7 8.5v5.306l2-.666V8.5a.5.5 0 0 1 .128-.334L13.5 3.308V2h-11z"/>
                            </svg>
                          </button>
                        </div>
                      </div>
                      <div class="col-md-8 text-end">
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary active" data-filter-type="all">Alle</button>
                          <button type="button" class="btn btn-outline-secondary" data-filter-type="ui">UI-Tests</button>
                          <button type="button" class="btn btn-outline-secondary" data-filter-type="functional">Funktionale Tests</button>
                          <button type="button" class="btn btn-outline-secondary" data-filter-type="e2e">E2E-Tests</button>
                        </div>
                      </div>
                    </div>
                    
                    <div class="table-responsive">
                      <table class="table table-hover table-sm">
                        <thead>
                          <tr>
                            <th>Test</th>
                            <th>Beschreibung</th>
                            <th>Funktionsbereiche</th>
                            <th>Selektoren</th>
                            <th>Assertions</th>
                            <th>Komplexität</th>
                            <th>Aktionen</th>
                          </tr>
                        </thead>
                        <tbody id="metadata-table-body">
                          <tr>
                            <td colspan="7" class="text-center">Führen Sie eine Analyse durch, um Test-Metadaten anzuzeigen.</td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                  </div>
                  
                  <!-- Abdeckungsmatrix Tab -->
                  <div class="tab-pane fade" id="coverage-content" role="tabpanel" aria-labelledby="coverage-tab">
                    <div class="alert alert-info mb-4">
                      <h5 class="alert-heading">Hinweis zur Abdeckung:</h5>
                      <p>Die Abdeckungsmatrix zeigt, welche Funktionsbereiche durch welche Testtypen abgedeckt werden.</p>
                    </div>
                    
                    <div class="table-responsive">
                      <table class="table table-bordered table-sm" id="coverage-matrix-table">
                        <thead>
                          <tr>
                            <th>Funktionsbereich / Testtyp</th>
                            <th>UI-Tests</th>
                            <th>Funktionale Tests</th>
                            <th>E2E-Tests</th>
                            <th>Accessibility Tests</th>
                          </tr>
                        </thead>
                        <tbody id="coverage-matrix-body">
                          <tr>
                            <td colspan="5" class="text-center">Führen Sie eine Analyse durch, um die Abdeckungsmatrix anzuzeigen.</td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                    
                    <div class="mt-4">
                      <h6>Abdeckungslücken</h6>
                      <div class="alert alert-danger" id="coverage-gaps">
                        Keine Daten verfügbar
                      </div>
                    </div>
                  </div>
                  
                  <!-- Entscheidungsmatrix Tab -->
                  <div class="tab-pane fade" id="decision-content" role="tabpanel" aria-labelledby="decision-tab">
                    <div class="alert alert-info mb-4">
                      <h5 class="alert-heading">Hinweis zur Entscheidungsmatrix:</h5>
                      <p>Die Entscheidungsmatrix hilft bei der Bewertung von Tests basierend auf Qualität und Abdeckung, um Optimierungspotenzial zu identifizieren.</p>
                    </div>
                    
                    <div class="row mb-4">
                      <div class="col-lg-6">
                        <div class="card">
                          <div class="card-header">
                            <h5 class="card-title mb-0">Entscheidungsmatrix</h5>
                          </div>
                          <div class="card-body">
                            <div id="decision-matrix-container" style="height: 300px;"></div>
                          </div>
                        </div>
                      </div>
                      <div class="col-lg-6">
                        <div class="card h-100">
                          <div class="card-header">
                            <h5 class="card-title mb-0">Entscheidungskategorien</h5>
                          </div>
                          <div class="card-body">
                            <div class="table-responsive">
                              <table class="table">
                                <thead>
                                  <tr>
                                    <th>Kategorie</th>
                                    <th>Beschreibung</th>
                                    <th>Empfehlung</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td><span class="badge bg-success">Beibehalten</span></td>
                                    <td>Hohe Qualität, gute Abdeckung</td>
                                    <td>Test beibehalten und regelmäßig ausführen</td>
                                  </tr>
                                  <tr>
                                    <td><span class="badge bg-warning">Optimieren</span></td>
                                    <td>Mittlere Qualität, wichtige Abdeckung</td>
                                    <td>Test verbessern (Selektoren, Assertions)</td>
                                  </tr>
                                  <tr>
                                    <td><span class="badge bg-danger">Konsolidieren</span></td>
                                    <td>Geringe Qualität, redundante Abdeckung</td>
                                    <td>Mit anderen Tests zusammenführen</td>
                                  </tr>
                                  <tr>
                                    <td><span class="badge bg-secondary">Archivieren</span></td>
                                    <td>Geringe Qualität, geringe Abdeckung</td>
                                    <td>Test archivieren oder entfernen</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <div class="card">
                      <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="card-title mb-0">Testbewertung & Empfehlungen</h5>
                        <div class="btn-group btn-group-sm">
                          <button type="button" class="btn btn-outline-primary" id="export-recommendations-btn">
                            <i class="bi bi-download"></i> Exportieren
                          </button>
                        </div>
                      </div>
                      <div class="card-body">
                        <div class="table-responsive">
                          <table class="table table-striped table-hover" id="decision-table">
                            <thead>
                              <tr>
                                <th>Test</th>
                                <th>Funktionsbereich</th>
                                <th>Qualitätsscore</th>
                                <th>Abdeckungsrelevanz</th>
                                <th>Empfehlung</th>
                                <th>Aktionen</th>
                              </tr>
                            </thead>
                            <tbody id="decision-table-body">
                              <tr>
                                <td colspan="6" class="text-center">Führen Sie eine Analyse durch, um Testempfehlungen zu erhalten.</td>
                              </tr>
                            </tbody>
                          </table>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Testkonsolidierung Tab -->
                  <div class="tab-pane fade" id="consolidate-content" role="tabpanel" aria-labelledby="consolidate-tab">
                    <div class="alert alert-info mb-4">
                      <h5 class="alert-heading">Testkonsolidierung:</h5>
                      <p>Dieses Tool identifiziert ähnliche oder redundante Tests und schlägt Möglichkeiten zur Zusammenführung vor.</p>
                    </div>
                    
                    <div class="row mb-4">
                      <div class="col-lg-5">
                        <div class="card">
                          <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="card-title mb-0">Test-Cluster</h5>
                            <button id="find-redundant-tests-btn" class="btn btn-sm btn-primary">
                              <i class="bi bi-search"></i> Redundanzen finden
                            </button>
                          </div>
                          <div class="card-body">
                            <div class="list-group" id="test-clusters-list">
                              <div class="text-center p-3">
                                <p class="text-muted">Klicken Sie auf "Redundanzen finden", um ähnliche Tests zu identifizieren.</p>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <div class="col-lg-7">
                        <div class="card">
                          <div class="card-header">
                            <h5 class="card-title mb-0">Konsolidierungsvorschlag</h5>
                          </div>
                          <div class="card-body">
                            <div id="consolidation-details">
                              <div class="alert alert-secondary">
                                <p class="mb-0">Wählen Sie links ein Test-Cluster aus, um Details und Konsolidierungsvorschläge zu sehen.</p>
                              </div>
                            </div>
                            
                            <div id="merge-recommendation" class="d-none">
                              <h6>Empfohlene Zusammenführung:</h6>
                              <div class="border rounded p-3 mb-3 bg-light">
                                <pre><code id="merged-test-preview">// Kein Vorschlag ausgewählt</code></pre>
                              </div>
                              
                              <div class="d-flex justify-content-end">
                                <button class="btn btn-sm btn-outline-secondary me-2" id="copy-merged-test-btn">
                                  <i class="bi bi-clipboard"></i> Kopieren
                                </button>
                                <button class="btn btn-sm btn-primary" id="apply-merge-btn">
                                  <i class="bi bi-check-lg"></i> Zusammenführen
                                </button>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <div class="card">
                      <div class="card-header">
                        <h5 class="card-title mb-0">Ähnlichkeitsmetriken</h5>
                      </div>
                      <div class="card-body">
                        <div class="row">
                          <div class="col-md-6">
                            <div class="table-responsive">
                              <table class="table table-sm">
                                <thead>
                                  <tr>
                                    <th>Metrik</th>
                                    <th>Beschreibung</th>
                                    <th>Schwellwert</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>Funktionsbereich</td>
                                    <td>Tests im gleichen Funktionsbereich</td>
                                    <td><span class="badge bg-success">Primär</span></td>
                                  </tr>
                                  <tr>
                                    <td>Selektorüberlappung</td>
                                    <td>Anteil identischer Selektoren</td>
                                    <td>&ge; 60%</td>
                                  </tr>
                                  <tr>
                                    <td>Assertions-Ähnlichkeit</td>
                                    <td>Ähnlichkeit der Prüfkriterien</td>
                                    <td>&ge; 50%</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="col-md-6">
                            <div id="similarity-chart-container" style="height: 250px;"></div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Test-Qualität Tab -->
                  <div class="tab-pane fade" id="quality-content" role="tabpanel" aria-labelledby="quality-tab">
                    <div class="row">
                      <div class="col-md-6">
                        <div class="card h-100">
                          <div class="card-header">Test-Komplexitätsverteilung</div>
                          <div class="card-body">
                            <div id="complexity-chart-container" style="height: 250px; position: relative;"></div>
                          </div>
                        </div>
                      </div>
                      <div class="col-md-6">
                        <div class="card h-100">
                          <div class="card-header">Selektor-Typen</div>
                          <div class="card-body">
                            <div id="selector-chart-container" style="height: 250px; position: relative;"></div>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <div class="row mt-4">
                      <div class="col-12">
                        <div class="card">
                          <div class="card-header">Test-Qualitätsmetriken</div>
                          <div class="card-body">
                            <div class="table-responsive">
                              <table class="table table-sm" id="quality-metrics-table">
                                <thead>
                                  <tr>
                                    <th>Metrik</th>
                                    <th>Wert</th>
                                    <th>Status</th>
                                    <th>Empfehlung</th>
                                  </tr>
                                </thead>
                                <tbody id="quality-metrics-body">
                                  <tr>
                                    <td colspan="4" class="text-center">Führen Sie eine Analyse durch, um Qualitätsmetriken anzuzeigen.</td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Test-Portfolio Tab -->
                  <div class="tab-pane fade" id="portfolio-content" role="tabpanel" aria-labelledby="portfolio-tab">
                    <div class="alert alert-info mb-4">
                      <h5 class="alert-heading">Test-Portfolio-Dokumentation:</h5>
                      <p>Dieses Tool bietet einen übergreifenden Überblick über alle Tests, ihre Dokumentation und Metriken für eine bessere Testmanagement-Strategie.</p>
                    </div>
                    
                    <div class="row mb-4">
                      <div class="col-lg-8">
                        <div class="card">
                          <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="card-title mb-0">Test-Katalog</h5>
                            <div>
                              <button id="export-portfolio-btn" class="btn btn-sm btn-outline-primary me-2">
                                <i class="bi bi-file-earmark-arrow-down"></i> Exportieren
                              </button>
                              <div class="btn-group">
                                <button class="btn btn-sm btn-primary dropdown-toggle" type="button" id="sortFilterBtn" data-bs-toggle="dropdown" aria-expanded="false">
                                  <i class="bi bi-funnel"></i> Filter & Sortierung
                                </button>
                                <ul class="dropdown-menu" aria-labelledby="sortFilterBtn">
                                  <li><h6 class="dropdown-header">Sortieren nach</h6></li>
                                  <li><a class="dropdown-item sort-option" href="#" data-sort="name">Name</a></li>
                                  <li><a class="dropdown-item sort-option" href="#" data-sort="area">Funktionsbereich</a></li>
                                  <li><a class="dropdown-item sort-option" href="#" data-sort="type">Testtyp</a></li>
                                  <li><a class="dropdown-item sort-option" href="#" data-sort="quality">Qualitätsscore</a></li>
                                  <li><hr class="dropdown-divider"></li>
                                  <li><h6 class="dropdown-header">Filter</h6></li>
                                  <li><a class="dropdown-item filter-option" href="#" data-filter="all">Alle Tests</a></li>
                                  <li><a class="dropdown-item filter-option" href="#" data-filter="documented">Nur dokumentierte</a></li>
                                  <li><a class="dropdown-item filter-option" href="#" data-filter="undocumented">Fehlende Dokumentation</a></li>
                                </ul>
                              </div>
                            </div>
                          </div>
                          <div class="card-body p-0">
                            <div class="table-responsive">
                              <table class="table table-hover mb-0" id="test-portfolio-table">
                                <thead class="table-light">
                                  <tr>
                                    <th style="width: 30%">Test</th>
                                    <th style="width: 20%">Funktionsbereich</th>
                                    <th style="width: 15%">Typ</th>
                                    <th style="width: 15%">Qualität</th>
                                    <th style="width: 10%">Docs</th>
                                    <th style="width: 10%">Aktionen</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td colspan="6" class="text-center p-3">
                                      <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
                                      Test-Katalog wird geladen...
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div class="card-footer">
                            <div class="d-flex justify-content-between align-items-center">
                              <span id="portfolio-summary">0 Tests im Katalog</span>
                              <div>
                                <span class="me-3"><i class="bi bi-circle-fill text-success me-1" style="font-size: 0.6rem;"></i> Dokumentiert: <span id="documented-count">0</span></span>
                                <span><i class="bi bi-circle-fill text-danger me-1" style="font-size: 0.6rem;"></i> Undokumentiert: <span id="undocumented-count">0</span></span>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <div class="col-lg-4">
                        <div class="card">
                          <div class="card-header">
                            <h5 class="card-title mb-0">Test-Dokumentation</h5>
                          </div>
                          <div class="card-body">
                            <div id="test-documentation-view">
                              <div class="alert alert-secondary">
                                <p class="mb-0">Wählen Sie einen Test aus dem Katalog, um seine Dokumentation anzuzeigen oder zu bearbeiten.</p>
                              </div>
                            </div>
                            
                            <div id="test-documentation-edit" class="d-none">
                              <form id="documentation-form">
                                <div class="mb-3">
                                  <label for="docTestName" class="form-label">Test-Name:</label>
                                  <input type="text" class="form-control" id="docTestName" readonly>
                                </div>
                                
                                <div class="mb-3">
                                  <label for="docDescription" class="form-label">Beschreibung:</label>
                                  <textarea class="form-control" id="docDescription" rows="4" placeholder="Beschreiben Sie den Zweck und das Verhalten dieses Tests..."></textarea>
                                </div>
                                
                                <div class="row mb-3">
                                  <div class="col-md-6">
                                    <label for="docAuthor" class="form-label">Autor:</label>
                                    <input type="text" class="form-control" id="docAuthor" placeholder="Name des Autors">
                                  </div>
                                  <div class="col-md-6">
                                    <label for="docLastUpdated" class="form-label">Zuletzt aktualisiert:</label>
                                    <input type="date" class="form-control" id="docLastUpdated">
                                  </div>
                                </div>
                                
                                <div class="mb-3">
                                  <label for="docNotes" class="form-label">Hinweise & Wartungsanforderungen:</label>
                                  <textarea class="form-control" id="docNotes" rows="3" placeholder="Spezielle Hinweise zur Wartung oder zu bekannten Problemen..."></textarea>
                                </div>
                                
                                <div class="mb-3">
                                  <label class="form-label d-block">Tags:</label>
                                  <div class="input-group">
                                    <input type="text" class="form-control" id="docTagInput" placeholder="Neuen Tag hinzufügen">
                                    <button class="btn btn-outline-secondary" type="button" id="addTagBtn">+</button>
                                  </div>
                                  <div class="mt-2" id="docTagsContainer">
                                    <!-- Tags werden hier angezeigt -->
                                  </div>
                                </div>
                                
                                <div class="d-flex justify-content-between mt-4">
                                  <button type="button" class="btn btn-outline-secondary" id="cancel-doc-btn">
                                    <i class="bi bi-x"></i> Abbrechen
                                  </button>
                                  <button type="submit" class="btn btn-primary" id="save-doc-btn">
                                    <i class="bi bi-check2"></i> Dokumentation speichern
                                  </button>
                                </div>
                              </form>
                            </div>
                          </div>
                        </div>
                        
                        <div class="card mt-4">
                          <div class="card-header">
                            <h5 class="card-title mb-0">Testmetriken</h5>
                          </div>
                          <div class="card-body p-0">
                            <ul class="list-group list-group-flush" id="test-metrics-list">
                              <li class="list-group-item d-flex justify-content-between">
                                <span>Test-Kategorie:</span>
                                <span id="metric-category" class="fw-bold">-</span>
                              </li>
                              <li class="list-group-item d-flex justify-content-between">
                                <span>Selektoren:</span>
                                <span id="metric-selectors" class="fw-bold">-</span>
                              </li>
                              <li class="list-group-item d-flex justify-content-between">
                                <span>Assertions:</span>
                                <span id="metric-assertions" class="fw-bold">-</span>
                              </li>
                              <li class="list-group-item d-flex justify-content-between">
                                <span>Testabdeckung:</span>
                                <span id="metric-coverage" class="fw-bold">-</span>
                              </li>
                              <li class="list-group-item d-flex justify-content-between">
                                <span>Stabilitätswert:</span>
                                <span id="metric-stability" class="fw-bold">-</span>
                              </li>
                            </ul>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <div class="card">
                      <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="card-title mb-0">Portfolio-Übersicht</h5>
                        <button class="btn btn-sm btn-outline-primary" id="generate-report-btn">
                          <i class="bi bi-file-earmark-text"></i> Bericht generieren
                        </button>
                      </div>
                      <div class="card-body">
                        <div class="row">
                          <div class="col-md-4">
                            <div class="card bg-light">
                              <div class="card-body">
                                <h6 class="card-title">Dokumentationsstand</h6>
                                <div id="documentation-status-chart-container" style="height: 200px;"></div>
                              </div>
                            </div>
                          </div>
                          <div class="col-md-4">
                            <div class="card bg-light">
                              <div class="card-body">
                                <h6 class="card-title">Tests nach Funktionsbereich</h6>
                                <div id="area-distribution-chart-container" style="height: 200px;"></div>
                              </div>
                            </div>
                          </div>
                          <div class="col-md-4">
                            <div class="card bg-light">
                              <div class="card-body">
                                <h6 class="card-title">Tests nach Typ</h6>
                                <div id="type-distribution-chart-container" style="height: 200px;"></div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-md-6 col-lg-3">
        <div class="card stat-card">
          <div class="number text-danger" id="criticalIssues">0</div>
          <div class="label">Kritische Probleme</div>
        </div>
      </div>
      <div class="col-md-6 col-lg-3">
        <div class="card stat-card">
          <div class="number text-warning" id="highIssues">0</div>
          <div class="label">Schwerwiegende Probleme</div>
        </div>
      </div>
      <div class="col-md-6 col-lg-3">
        <div class="card stat-card">
          <div class="number text-info" id="mediumIssues">0</div>
          <div class="label">Mittlere Probleme</div>
        </div>
      </div>
      <div class="col-md-6 col-lg-3">
        <div class="card stat-card">
          <div class="number text-secondary" id="lowIssues">0</div>
          <div class="label">Leichte Probleme</div>
        </div>
      </div>
    </div>

    <div class="row mt-4">
      <div class="col-lg-8">
        <div class="card">
          <div class="card-header">
            Probleme nach Template
          </div>
          <div class="card-body">
            <div class="chart-container">
              <canvas id="issuesChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      <div class="col-lg-4">
        <div class="card">
          <div class="card-header">
            Verteilung nach Schweregrad
          </div>
          <div class="card-body">
            <div class="chart-container" style="height: 300px;">
              <canvas id="severityChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card mt-4">
      <div class="card-header">
        UX-Probleme
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-striped table-hover issue-table" id="issuesTable">
            <thead>
              <tr>
                <th>Schweregrad</th>
                <th>Problem</th>
                <th>Beschreibung</th>
                <th>Template</th>
                <th>Empfehlung</th>
                <th>Datum</th>
              </tr>
            </thead>
            <tbody id="issuesTableBody">
              <!-- Wird dynamisch gefüllt -->
              <tr>
                <td colspan="5" class="text-center">Laden...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>



    <div class="row mt-4">
      <div class="col-md-8">
        <div class="card">
          <div class="card-header">
            Top-Empfehlungen
          </div>
          <div class="card-body" id="recommendationsContainer">
            <!-- Wird dynamisch gefüllt -->
            <div class="alert alert-info">
              Laden der Empfehlungen...
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-4">
        <div class="card">
          <div class="card-header">
            UX-Score Trend
          </div>
          <div class="card-body">
            <div class="chart-container">
              <canvas id="trendChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer class="footer mt-5">
    <div class="container text-center">
      <p>UX-Test Framework Dashboard | Evolution Hub &copy; 2025</p>
    </div>
  </footer>

  <!-- Bootstrap JavaScript Bundle (mit Popper.js) für UI-Komponenten -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Chart.js für Diagramme -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  
  <!-- Testmetriken-Module -->
  <script src="/js/metrics/success-rate-view.js"></script>
  <script src="/js/metrics/flakiness-view.js"></script>
  <!-- Logger Viewer Script -->
  <script src="/public/js/logs.js"></script>
  <!-- Dashboard JavaScript direkt eingebettet -->
  <script>
    // Globale Variablen für Charts
    let complexityChart, selectorChart, matrixChart, decisionMatrixChart, clusterChart;
    let documentationStatusChart, areaDistributionChart, typeDistributionChart;
    let testClusters = [];
    let selectedCluster = null;
    let selectedTestId = null;
    
    // Debug-Logging-Funktion
    const DEBUG_MODE = true; // Auf true setzen für detaillierte Logs
    function logDebug(message, data) {
      if (DEBUG_MODE) {
        if (data) {
          console.log(`%c[Dashboard Debug] ${message}`, 'color: #6610f2', data);
        } else {
          console.log(`%c[Dashboard Debug] ${message}`, 'color: #6610f2');
        }
      }
    }
    let metadataTableBody = null;
    let qualityMetricsBody = null;
    let analysisStatus = null;
    let analysisSpinner = null;
    
    // Playwright-Tests UI-Integration
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Dashboard initialisiert');

      // Playwright-Tests laden, wenn das Dokument geladen ist
      fetchPlaywrightTests();

      // Event-Listener für den Tab-Wechsel
      const tabEls = document.querySelectorAll('button[data-bs-toggle="tab"]');
      tabEls.forEach(tabEl => {
        tabEl.addEventListener('shown.bs.tab', function() {
          console.log('Tab aktiviert:', tabEl.textContent);
        });
      });
    });

    // Playwright-Tests von der API laden
    function fetchPlaywrightTests() {
      console.log('Lade Playwright-Tests...');
      const tableBody = document.getElementById('playwright-tests-table-body');
      
      if (tableBody) {
        tableBody.innerHTML = '<tr><td colspan="4" class="text-center">Lade Tests...</td></tr>';
      }
      
      // Abfrage mit Cache-Control-Headers und Fehlerbehandlung
      fetch('/api/playwright-tests', {
        method: 'GET',
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP-Fehler ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        console.log('API-Antwort erhalten:', data);
        
        if (data.status === 'success' && Array.isArray(data.tests)) {
          console.log(`${data.tests.length} Tests gefunden`);  
          updatePlaywrightTestsTable(data.tests);
        } else {
          showError('Unerwartetes Datenformat vom Server');
        }
      })
      .catch(error => {
        console.error('Fehler beim Laden der Tests:', error);
        showError(`Fehler beim Laden der Tests: ${error.message}`);
      });
    }

    // Tests in der Tabelle anzeigen
    function updatePlaywrightTestsTable(tests) {
      const tableBody = document.getElementById('playwright-tests-table-body');
      
      if (!tableBody) {
        console.error('Tabellenelement nicht gefunden');
        return;
      }
      
      try {
        // Tabelle leeren
        tableBody.innerHTML = '';
        
        if (tests.length === 0) {
          tableBody.innerHTML = '<tr><td colspan="4" class="text-center">Keine Tests gefunden</td></tr>';
          return;
        }
        
        // Tests hinzufügen
        tests.forEach((test, index) => {
          const row = document.createElement('tr');
          
          // Checkbox-Zelle
          const checkboxCell = document.createElement('td');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.className = 'form-check-input test-checkbox';
          checkbox.dataset.testFile = test.file;
          checkboxCell.appendChild(checkbox);
          row.appendChild(checkboxCell);
          
          // Dateiname-Zelle
          const fileCell = document.createElement('td');
          fileCell.textContent = test.file;
          row.appendChild(fileCell);
          
          // Beschreibungs-Zelle
          const descCell = document.createElement('td');
          descCell.textContent = test.description || `Playwright-Test: ${test.file}`;
          row.appendChild(descCell);
          
          // Aktionen-Zelle
          const actionsCell = document.createElement('td');
          const runButton = document.createElement('button');
          runButton.className = 'btn btn-sm btn-success';
          runButton.textContent = 'Ausführen';
          runButton.dataset.testFile = test.file;
          
          // Echter Test-Ausführungs-Event-Listener
          runButton.addEventListener('click', function() {
            const testFile = test.file;
            runPlaywrightTest(testFile, runButton);
          });
          
          actionsCell.appendChild(runButton);
          row.appendChild(actionsCell);
          
          tableBody.appendChild(row);
        });
        
        console.log('Tabelle erfolgreich aktualisiert');
      } catch (error) {
        console.error('Fehler beim Aktualisieren der Tabelle:', error);
        showError(`Fehler beim Aktualisieren der Tabelle: ${error.message}`);
      }
    }

    // Zeigt eine Fehlermeldung an
    function showError(message) {
      const tableBody = document.getElementById('playwright-tests-table-body');
      if (tableBody) {
        tableBody.innerHTML = `<tr><td colspan="4" class="text-center text-danger">${message}</td></tr>`;
      }
      
      // Zusätzliche Fehlermeldung über der Tabelle
      const errorMsg = document.createElement('div');
      errorMsg.className = 'alert alert-danger mt-2';
      errorMsg.textContent = message;
      
      const table = document.getElementById('playwright-tests-table');
      if (table && table.parentElement) {
        table.parentElement.insertBefore(errorMsg, table);
      }
    }
    
    // Zeigt eine Erfolgsmeldung an
    function showSuccess(message) {
      // Erfolgsmeldung über der Tabelle
      const successMsg = document.createElement('div');
      successMsg.className = 'alert alert-success mt-2';
      successMsg.textContent = message;
      
      // Entferne alte Meldungen
      document.querySelectorAll('.alert').forEach(el => el.remove());
      
      const table = document.getElementById('playwright-tests-table');
      if (table && table.parentElement) {
        table.parentElement.insertBefore(successMsg, table);
        
        // Nach 5 Sekunden automatisch ausblenden
        setTimeout(() => {
          successMsg.style.transition = 'opacity 1s';
          successMsg.style.opacity = '0';
          setTimeout(() => successMsg.remove(), 1000);
        }, 5000);
      }
    }
    
    // Führt einen Playwright-Test aus
    function runPlaywrightTest(testFile, buttonElement) {
      if (!testFile) {
        showError('Keine Test-Datei angegeben');
        return;
      }
      
      // Button deaktivieren und Status anzeigen
      const originalText = buttonElement.textContent;
      buttonElement.disabled = true;
      buttonElement.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Läuft...';
      
      // API-Anfrage an den Server senden
      fetch('/api/run-playwright-test', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ testFile })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP-Fehler ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        console.log('Test-Ausführungsergebnis:', data);
        
        if (data.status === 'success' && data.result) {
          // Erfolgreiche Ausführung
          showSuccess(`Test ${testFile} erfolgreich ausgeführt (${data.result.duration}ms)`);
          
          // Test-Zeile in der Tabelle grün hervorheben
          const row = buttonElement.closest('tr');
          if (row) {
            row.classList.add('table-success');
            setTimeout(() => row.classList.remove('table-success'), 5000);
          }
        } else {
          showError(`Test-Ausführung fehlgeschlagen: ${data.message || 'Unbekannter Fehler'}`);
        }
      })
      .catch(error => {
        console.error('Fehler bei der Test-Ausführung:', error);
        showError(`Fehler bei der Test-Ausführung: ${error.message}`);
      })
      .finally(() => {
        // Button wieder aktivieren
        buttonElement.disabled = false;
        buttonElement.textContent = originalText;
      });
    }
    
    // Alle ausgewählten Tests ausführen
    document.querySelectorAll('.tests-ausfuehren-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const checkedTests = document.querySelectorAll('.test-checkbox:checked');
        
        if (checkedTests.length === 0) {
          // Wenn keine Tests ausgewählt sind, alle Buttons auswählen
          const allButtons = document.querySelectorAll('button[data-test-file]');
          if (allButtons.length > 0) {
            showSuccess(`Starte alle ${allButtons.length} Tests...`);
            
            // Sequentiell alle Tests ausführen
            let currentIndex = 0;
            function runNextTest() {
              if (currentIndex < allButtons.length) {
                const button = allButtons[currentIndex];
                const testFile = button.dataset.testFile;
                currentIndex++;
                
                // Kurze Verzögerung zwischen den Tests
                setTimeout(() => {
                  runPlaywrightTest(testFile, button);
                  runNextTest(); // Nächsten Test starten
                }, 500);
              } else {
                showSuccess('Alle Tests abgeschlossen!');
              }
            }
            
            runNextTest(); // Ersten Test starten
          }
        } else {
          showSuccess(`Starte ${checkedTests.length} ausgewählte Tests...`);
          
          // Ausgewählte Tests ausführen
          checkedTests.forEach(checkbox => {
            const testFile = checkbox.dataset.testFile;
            const row = checkbox.closest('tr');
            if (row) {
              const button = row.querySelector('button[data-test-file]');
              if (button && testFile) {
                runPlaywrightTest(testFile, button);
              }
            }
          });
        }
      });
    });
  </script>

  <!-- JavaScript für die Test-Analyse -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Test-Analyse Funktionalität - Initialisierung der globalen Variablen
      const runAnalysisBtn = document.getElementById('run-analysis-btn');
      analysisSpinner = document.getElementById('analysis-spinner');
      analysisStatus = document.getElementById('analysis-status');
      metadataTableBody = document.getElementById('metadata-table-body');
      coverageMatrixBody = document.getElementById('coverage-matrix-body');
      coverageGaps = document.getElementById('coverage-gaps');
      qualityMetricsBody = document.getElementById('quality-metrics-body');
      const metadataSearch = document.getElementById('metadata-search');
      const metadataFilterBtn = document.getElementById('metadata-filter-btn');
      
      // Filter-Buttons für Test-Metadaten
      const filterTypeButtons = document.querySelectorAll('[data-filter-type]');
      
      // Debug-Ausgabe zur Überprüfung der Elemente
      console.log('DOM-Elemente geladen:', {
        metadataTableBody: !!metadataTableBody,
        coverageMatrixBody: !!coverageMatrixBody,
        coverageGaps: !!coverageGaps,
        qualityMetricsBody: !!qualityMetricsBody,
        filterButtons: filterTypeButtons.length
      });
      
      // Diagramm-Initialisierung erfolgt global
      
      // Lade gespeicherte Analyseergebnisse beim Start, falls vorhanden
      loadAnalysisResults();
      
      // Event-Handler für den Analyse-Button
      if (runAnalysisBtn) {
        runAnalysisBtn.addEventListener('click', function() {
          runTestAnalysis();
        });
      }
      
      // Filter-Buttons für die Test-Typen
      if (filterTypeButtons) {
        filterTypeButtons.forEach(button => {
          button.addEventListener('click', function() {
            // Aktiven Button markieren
            filterTypeButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            
            const filterType = this.dataset.filterType;
            filterTestMetadata(filterType, metadataSearch.value);
          });
        });
      }
      
      // Suche in den Test-Metadaten
      if (metadataSearch && metadataFilterBtn) {
        metadataFilterBtn.addEventListener('click', function() {
          const activeFilter = document.querySelector('[data-filter-type].active');
          const filterType = activeFilter ? activeFilter.dataset.filterType : 'all';
          filterTestMetadata(filterType, metadataSearch.value);
        });
        
        metadataSearch.addEventListener('keyup', function(event) {
          if (event.key === 'Enter') {
            const activeFilter = document.querySelector('[data-filter-type].active');
            const filterType = activeFilter ? activeFilter.dataset.filterType : 'all';
            filterTestMetadata(filterType, metadataSearch.value);
          }
        });
      }
      
      /**
       * Test-Analyse ausführen
       */
      function runTestAnalysis() {
        // UI-Status aktualisieren
        showAnalysisLoading(true);
        updateAnalysisStatus('info', 'Test-Analyse wird ausgeführt...');
        
        console.log('Test-Analyse API-Aufruf gestartet...');
        
        // API-Aufruf zur Analyse der Tests
        fetch('/api/test-analysis', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({}) // Leeres Objekt, kann später mit Optionen erweitert werden
        })
        .then(response => {
          console.log('API-Antwort erhalten:', response.status, response.statusText);
          if (!response.ok) {
            throw new Error('Fehler bei der Analyse: ' + response.statusText);
          }
          return response.json();
        })
        .then(data => {
          // Debug-Informationen
          console.log('API-Daten erhalten:', data);
          console.log('Test-Metadaten vorhanden:', Array.isArray(data.testMetadata), 
                     'Anzahl Tests:', data.testMetadata ? data.testMetadata.length : 0);
          console.log('Coverage-Matrix vorhanden:', !!data.coverageMatrix, 
                     'Anzahl Bereiche:', data.coverageMatrix?.areas?.length || 0);
          
          // Analyseergebnisse anzeigen
          updateAnalysisStatus('success', 'Analyse abgeschlossen!');
          
          if (!data.testMetadata || !Array.isArray(data.testMetadata)) {
            console.error('Ungültiges Format der Testmetadaten:', data.testMetadata);
            updateAnalysisStatus('warning', 'Keine gültigen Testdaten erhalten');
            return;
          }
          
          try {
            displayTestMetadata(data.testMetadata || []);
            displayCoverageMatrix(data.coverageMatrix || {});
            displayQualityMetrics(data.qualityMetrics || {});
            initCharts(data);
            
            // Erfolgs-Nachricht mit Details
            const testCount = data.testMetadata.length;
            document.getElementById('analysis-status').innerHTML = 
              `<div class="alert alert-success">
                <strong>Analyse abgeschlossen!</strong> 
                ${testCount} Tests gefunden und analysiert.
               </div>`;
          } catch (displayError) {
            console.error('Fehler beim Anzeigen der Daten:', displayError);
            updateAnalysisStatus('warning', `Fehler bei der Datenanzeige: ${displayError.message}`);
          }
        })
        .catch(error => {
          console.error('Fehler bei der Test-Analyse:', error);
          updateAnalysisStatus('danger', `Fehler bei der Analyse: ${error.message}`);
        })
        .finally(() => {
          // Lade-Status zurücksetzen
          showAnalysisLoading(false);
        });
      }
      
      /**
       * Gespeicherte Analyseergebnisse laden
       */
      function loadAnalysisResults() {
        fetch('/api/test-analysis/results')
        .then(response => {
          if (!response.ok) {
            throw new Error('Keine gespeicherten Ergebnisse verfügbar');
          }
          return response.json();
        })
        .then(data => {
          if (data && data.testMetadata && data.testMetadata.length > 0) {
            updateAnalysisStatus('info', 'Letzte Analyseergebnisse geladen');
            displayTestMetadata(data.testMetadata || []);
            displayCoverageMatrix(data.coverageMatrix || {});
            displayQualityMetrics(data.qualityMetrics || {});
            initCharts(data);
          }
        })
        .catch(error => {
          console.log('Keine gespeicherten Analyseergebnisse:', error.message);
          // Kein Error-Status nötig, da es normal ist, keine Ergebnisse zu haben
        });
      }
      
      /**
       * Test-Metadaten in der Tabelle anzeigen
       */
      function displayTestMetadata(metadata) {
        if (!metadataTableBody) return;
        
        if (!metadata || metadata.length === 0) {
          metadataTableBody.innerHTML = `<tr><td colspan="7" class="text-center">Keine Test-Metadaten verfügbar</td></tr>`;
          return;
        }
        
        metadataTableBody.innerHTML = '';
        
        metadata.forEach(test => {
          const complexity = calculateComplexity(test);
          const row = document.createElement('tr');
          row.dataset.testType = test.testType || 'unknown';
          row.dataset.testName = test.name || '';
          
          row.innerHTML = `
            <td>${test.name || 'Unbenannt'}</td>
            <td>${test.description || '-'}</td>
            <td>${formatFunctionalAreas(test.functionalAreas || [])}</td>
            <td>${test.selectors ? test.selectors.length : 0}</td>
            <td>${test.assertions ? test.assertions.length : 0}</td>
            <td>${formatComplexity(complexity)}</td>
            <td>
              <button class="btn btn-sm btn-outline-info view-test-btn" data-test-name="${test.name}">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
                  <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                  <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                </svg>
              </button>
            </td>
          `;
          
          metadataTableBody.appendChild(row);
        });
        
        // Event-Handler für Detail-Buttons
        const viewTestButtons = document.querySelectorAll('.view-test-btn');
        viewTestButtons.forEach(button => {
          button.addEventListener('click', function() {
            const testName = this.dataset.testName;
            // Hier könnte ein Modal oder ein Detail-Bereich mit zusätzlichen Testinformationen angezeigt werden
            alert(`Detailansicht für Test: ${testName} (Wird in einem zukünftigen Update implementiert)`); 
          });
        });
      }
      
      /**
       * Konvertiert die Matrixdaten vom Backend in ein für das Frontend verwendbares Format
       */
      function convertMatrixFormat(matrix) {
        if (!matrix) return null;
        
        // Extrahiere alle Bereiche (Zeilen) und Testtypen (Spalten) aus den Matrixschlüsseln
        const areas = Object.keys(matrix);
        if (areas.length === 0) return null;
        
        // Sammle alle Testtypen aus allen Bereichen
        const testTypes = new Set();
        areas.forEach(area => {
          Object.keys(matrix[area]).forEach(type => testTypes.add(type));
        });
        
        // Erstelle die Abdeckungsdaten - zähle Tests pro Bereich/Typ
        const coverage = {};
        areas.forEach(area => {
          coverage[area] = {};
          Array.from(testTypes).forEach(type => {
            const tests = matrix[area][type];
            coverage[area][type] = tests ? tests.length : 0;
          });
        });
        
        return {
          areas: areas,
          testTypes: Array.from(testTypes),
          coverage: coverage
        };
      }
      
      /**
       * Identifiziert Lücken in der Testabdeckung
       */
      function identifyCoverageGaps(formattedMatrix) {
        if (!formattedMatrix) return [];
        
        const gaps = [];
        
        // Suche nach Bereichen ohne Tests
        formattedMatrix.areas.forEach(area => {
          let hasTests = false;
          
          formattedMatrix.testTypes.forEach(type => {
            if (formattedMatrix.coverage[area][type] > 0) {
              hasTests = true;
            }
          });
          
          if (!hasTests) {
            gaps.push(`Funktionsbereich "${area}" hat keine Tests`);
          }
        });
        
        // Suche nach Testtypen, die in Bereichen fehlen
        formattedMatrix.areas.forEach(area => {
          formattedMatrix.testTypes.forEach(type => {
            if (formattedMatrix.coverage[area][type] === 0) {
              gaps.push(`Keine Tests vom Typ "${type}" für Bereich "${area}"`);
            }
          });
        });
        
        return gaps.slice(0, 10); // Begrenze auf die 10 wichtigsten Lücken
      }
      
      /**
       * Abdeckungsmatrix anzeigen
       */
      function displayCoverageMatrix(rawMatrix) {
        if (!coverageMatrixBody || !rawMatrix) {
          console.error('Fehler: coverageMatrixBody nicht gefunden oder Matrix leer');
          return;
        }
        
        // Konvertiere in das für das Frontend benötigte Format
        const formattedMatrix = convertMatrixFormat(rawMatrix);
        
        if (!formattedMatrix) {
          console.error('Fehler: Matrix konnte nicht formatiert werden');
          coverageMatrixBody.innerHTML = '<tr><td colspan="10" class="text-center">Keine gültigen Matrixdaten verfügbar</td></tr>';
          return;
        }
        
        console.log('Formatierte Matrix:', formattedMatrix);
        
        coverageMatrixBody.innerHTML = '';
        
        // Funktionsbereiche in Zeilen darstellen
        formattedMatrix.areas.forEach(area => {
          const row = document.createElement('tr');
          
          // Bereichsname als erste Spalte
          const areaCell = document.createElement('td');
          areaCell.textContent = area;
          row.appendChild(areaCell);
          
          // Für jeden Testtyp eine Spalte mit Abdeckungsindikator
          formattedMatrix.testTypes.forEach(testType => {
            const cell = document.createElement('td');
            const coverage = formattedMatrix.coverage[area][testType];
            
            if (coverage && coverage > 0) {
              // Farbige Abdeckungsanzeige basierend auf der Anzahl der Tests
              const coverageClass = coverage > 3 ? 'bg-success' : 
                                  coverage > 1 ? 'bg-info' : 'bg-warning';
              
              cell.innerHTML = `<span class="badge ${coverageClass}">${coverage}</span>`;
            } else {
              cell.innerHTML = `<span class="text-muted">-</span>`;
            }
            
            row.appendChild(cell);
          });
          
          coverageMatrixBody.appendChild(row);
        });
        
        // Abdeckungslücken anzeigen
        const gaps = identifyCoverageGaps(formattedMatrix);
        displayCoverageGaps(gaps);
      }
      
      /**
       * Abdeckungslücken anzeigen
       */
      function displayCoverageGaps(gaps) {
        if (!coverageGaps) return;
        
        // Lücken in der UI darstellen
        if (gaps && gaps.length > 0) {
          let gapsHtml = '<ul class="mb-0">';
          gaps.forEach(gap => {
            gapsHtml += `<li>${gap}</li>`;
          });
          gapsHtml += '</ul>';
          coverageGaps.innerHTML = gapsHtml;
        } else {
          coverageGaps.innerHTML = '<p class="mb-0">Keine signifikanten Abdeckungslücken gefunden.</p>';
        }
      }
      
      /**
       * Berechnet Qualitätsmetriken aus den Testdaten
       */
      function calculateQualityMetrics(testMetadata) {
        const metrics = {};
        
        if (!testMetadata || testMetadata.length === 0) return metrics;
        
        // Durchschnittliche Selektoren pro Test berechnen
        let totalSelectors = 0;
        let testsWithSelectors = 0;
        
        // Durchschnittliche Assertions pro Test berechnen
        let totalAssertions = 0;
        let testsWithAssertions = 0;
        
        // Selektortypen zählen für Selektorqualität
        let testIdSelectors = 0;
        let roleSelectors = 0;
        let textSelectors = 0;
        let cssSelectors = 0;
        let xpathSelectors = 0;
        
        testMetadata.forEach(test => {
          if (test.selectors && test.selectors.length > 0) {
            totalSelectors += test.selectors.length;
            testsWithSelectors++;
            
            // Zähle Selektortypen
            test.selectors.forEach(selector => {
              if (selector.type === 'testId') testIdSelectors++;
              else if (selector.type === 'role') roleSelectors++;
              else if (selector.type === 'text') textSelectors++;
              else if (selector.type === 'css') cssSelectors++;
              else if (selector.type === 'xpath') xpathSelectors++;
            });
          }
          
          if (test.assertions && test.assertions > 0) {
            totalAssertions += test.assertions;
            testsWithAssertions++;
          }
        });
        
        // Metriken berechnen
        const avgSelectors = testsWithSelectors > 0 ? (totalSelectors / testsWithSelectors).toFixed(1) : 0;
        const avgAssertions = testsWithAssertions > 0 ? (totalAssertions / testsWithAssertions).toFixed(1) : 0;
        
        // Selektorqualität berechnen (höhere Werte für testId und role, niedrigere für css und xpath)
        const totalSelectorCount = testIdSelectors + roleSelectors + textSelectors + cssSelectors + xpathSelectors;
        let selectorQuality = 0;
        
        if (totalSelectorCount > 0) {
          const testIdWeight = 1.0;
          const roleWeight = 0.8;
          const textWeight = 0.6;
          const cssWeight = 0.4;
          const xpathWeight = 0.2;
          
          selectorQuality = (testIdSelectors * testIdWeight + 
                            roleSelectors * roleWeight + 
                            textSelectors * textWeight + 
                            cssSelectors * cssWeight + 
                            xpathSelectors * xpathWeight) / totalSelectorCount;
          
          // Auf Skala von 0-100 normalisieren
          selectorQuality = Math.round(selectorQuality * 100);
        }
        
        // Testabdeckung berechnen (vereinfachte Berechnung basierend auf Funktionsbereichen)
        const coveredAreas = new Set();
        testMetadata.forEach(test => {
          if (test.coverage && test.coverage.area) {
            test.coverage.area.forEach(area => coveredAreas.add(area));
          }
        });
        
        // Annahme: es gibt ungefähr 10 wichtige Funktionsbereiche in der Anwendung (anpassen nach Bedarf)
        const estimatedTotalAreas = 10;
        const coveragePercentage = Math.min(100, Math.round((coveredAreas.size / estimatedTotalAreas) * 100));
        
        // Metriken zusammenstellen
        metrics['Durchschnittliche Selektoren pro Test'] = {
          value: avgSelectors,
          status: avgSelectors >= 3 ? 'success' : 'warning',
          recommendation: avgSelectors < 3 ? 'Erhöhen Sie die Anzahl der Selektoren für robustere Tests.' : 'Gute Abdeckung mit Selektoren.'
        };
        
        metrics['Durchschnittliche Assertions pro Test'] = {
          value: avgAssertions,
          status: avgAssertions >= 2 ? 'success' : 'warning',
          recommendation: avgAssertions < 2 ? 'Erhöhen Sie die Anzahl der Assertions für gründlichere Tests.' : 'Gute Prüfungsabdeckung.'
        };
        
        metrics['Selektorqualität'] = {
          value: selectorQuality + '%',
          status: selectorQuality >= 70 ? 'success' : selectorQuality >= 50 ? 'warning' : 'danger',
          recommendation: selectorQuality < 70 ? 'Verwenden Sie mehr testId und role-basierte Selektoren.' : 'Gute Selektorqualität.'
        };
        
        metrics['Testabdeckung'] = {
          value: coveragePercentage + '%',
          status: coveragePercentage >= 80 ? 'success' : coveragePercentage >= 50 ? 'warning' : 'danger',
          recommendation: coveragePercentage < 80 ? 'Erweitern Sie Tests auf mehr Funktionsbereiche.' : 'Gute Testabdeckung.'
        };
        
        return metrics;
      }
      
      /**
       * Test-Qualitätsmetriken anzeigen
       */
      function displayQualityMetrics(data) {
        if (!qualityMetricsBody) return;
        
        qualityMetricsBody.innerHTML = '';
        
        // Berechne Metriken aus den Testdaten
        const metrics = calculateQualityMetrics(data.testMetadata || []);
        
        // Fallback-Metriken, wenn keine Daten verfügbar sind
        if (Object.keys(metrics).length === 0) {
          metrics['Durchschnittliche Selektoren pro Test'] = { value: 'N/A', status: 'info', recommendation: 'Führen Sie eine Analyse durch.' };
          metrics['Durchschnittliche Assertions pro Test'] = { value: 'N/A', status: 'info', recommendation: 'Führen Sie eine Analyse durch.' };
          metrics['Selektorqualität'] = { value: 'N/A', status: 'info', recommendation: 'Führen Sie eine Analyse durch.' };
          metrics['Testabdeckung'] = { value: 'N/A', status: 'info', recommendation: 'Führen Sie eine Analyse durch.' };
        }
        
        // Metriken in der Tabelle anzeigen
        Object.entries(metrics).forEach(([metric, data]) => {
          const row = document.createElement('tr');
          
          const statusClass = data.status === 'success' ? 'text-success' :
                              data.status === 'warning' ? 'text-warning' :
                              data.status === 'danger' ? 'text-danger' : 'text-info';
          
          row.innerHTML = `
            <td>${metric}</td>
            <td>${data.value}</td>
            <td><span class="${statusClass}">${formatStatus(data.status)}</span></td>
            <td>${data.recommendation || '-'}</td>
          `;
          
          qualityMetricsBody.appendChild(row);
        });
      }
      
      /**
       * Diagramme initialisieren und darstellen
       */
      function initCharts(data) {
        // Chart.js verwenden, falls verfügbar
        if (typeof Chart === 'undefined') {
          console.warn('Chart.js ist nicht geladen. Diagramme werden nicht angezeigt.');
          return;
        }
        
        try {
          console.log('Starte Chart-Initialisierung');
          
          // Container-Elemente finden
          const complexityContainer = document.getElementById('complexity-chart-container');
          const selectorContainer = document.getElementById('selector-chart-container');
          
          if (!complexityContainer || !selectorContainer) {
            console.error('Chart-Container nicht gefunden:', { 
              complexityContainer: !!complexityContainer,
              selectorContainer: !!selectorContainer 
            });
            return;
          }
          
          // WICHTIG: Vorhandene Charts zerstören
          if (complexityChart) {
            complexityChart.destroy();
            complexityChart = null;
          }
          
          if (selectorChart) {
            selectorChart.destroy();
            selectorChart = null;
          }
          
          // Container vollständig leeren und neue Canvas-Elemente erstellen
          complexityContainer.innerHTML = '';
          selectorContainer.innerHTML = '';
          
          const complexityCanvas = document.createElement('canvas');
          complexityCanvas.height = 250;
          complexityContainer.appendChild(complexityCanvas);
          
          const selectorCanvas = document.createElement('canvas');
          selectorCanvas.height = 250;
          selectorContainer.appendChild(selectorCanvas);
          
          // Komplexitätsverteilung berechnen
          const complexityData = calculateComplexityDistribution(data.testMetadata || []);
          console.log('Berechnete Komplexitätsverteilung:', complexityData);
          
          // Selektor-Typen berechnen
          const selectorData = calculateSelectorTypes(data.testMetadata || []);
          console.log('Berechnete Selektor-Typen:', selectorData);
          
          // Komplexitäts-Chart erstellen
          complexityChart = new Chart(complexityCanvas, {
            type: 'bar',
            data: {
              labels: ['Einfach', 'Mittel', 'Komplex', 'Sehr komplex'],
              datasets: [{
                label: 'Anzahl Tests',
                data: [
                  complexityData.simple || 0,
                  complexityData.medium || 0,
                  complexityData.complex || 0,
                  complexityData.veryComplex || 0
                ],
                backgroundColor: ['#28a745', '#17a2b8', '#ffc107', '#dc3545']
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  precision: 0
                }
              }
            }
          });
          
          // Selektor-Chart erstellen
          selectorChart = new Chart(selectorCanvas, {
            type: 'pie',
            data: {
              labels: Object.keys(selectorData),
              datasets: [{
                data: Object.values(selectorData),
                backgroundColor: [
                  '#28a745', '#17a2b8', '#ffc107', '#dc3545', 
                  '#007bff', '#6c757d', '#6f42c1', '#e83e8c'
                ]
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'right'
                }
              }
            }
          });
          
          console.log('Charts erfolgreich initialisiert mit neuer Methode');
        } catch (error) {
          console.error('Fehler bei der Chart-Initialisierung:', error);
        }
      }
      
      /**
       * Test-Metadaten filtern
       */
      function filterTestMetadata(type, searchText) {
        const rows = document.querySelectorAll('#metadata-table-body tr');
        
        rows.forEach(row => {
          const testType = row.dataset.testType;
          const testName = row.dataset.testName;
          
          let matchesType = type === 'all' || testType === type;
          let matchesSearch = !searchText || testName.toLowerCase().includes(searchText.toLowerCase());
          
          row.style.display = matchesType && matchesSearch ? '' : 'none';
        });
      }
      
      /**
       * Testkomplexität berechnen (einfache Metrik)
       */
      function calculateComplexity(test) {
        if (!test) return 0;
        
        // Faktoren: Selektoren, Assertions, Steps, Interactions
        const selectorCount = test.selectors ? test.selectors.length : 0;
        const assertionCount = test.assertions ? test.assertions.length : 0;
        const stepsCount = test.steps ? test.steps.length : 0;
        
        // Gewichtete Komplexität berechnen
        return selectorCount * 0.3 + assertionCount * 0.5 + stepsCount * 0.2;
      }
      
      /**
       * Komplexitätsverteilung berechnen
       */
      function calculateComplexityDistribution(tests) {
        const distribution = {
          simple: 0,      // < 5
          medium: 0,      // 5-10
          complex: 0,     // 10-15
          veryComplex: 0  // > 15
        };
        
        tests.forEach(test => {
          const complexity = calculateComplexity(test);
          
          if (complexity < 5) distribution.simple++;
          else if (complexity < 10) distribution.medium++;
          else if (complexity < 15) distribution.complex++;
          else distribution.veryComplex++;
        });
        
        return distribution;
      }
      
      /**
       * Zählt die verschiedenen Selektortypen für das Diagramm
       * Unterstützt sowohl das alte String-Format als auch die neue TestSelector-Struktur
       */
      function calculateSelectorTypes(tests) {
        const selectorTypes = {
          'ID-Selektor': 0,
          'Class-Selektor': 0,
          'Tag-Selektor': 0,
          'Attribut-Selektor': 0,
          'CSS-Selektor': 0,
          'XPath': 0,
          'Text-Selektor': 0,
          'Role-Selektor': 0,
          'TestID-Selektor': 0,
          'Andere': 0
        };
        
        console.log('Verarbeite Selektoren für', tests.length, 'Tests');
        
        tests.forEach(test => {
          if (!test.selectors) {
            console.log('Test ohne Selektoren:', test.name || test.file);
            return;
          }
          
          test.selectors.forEach(selector => {
            try {
              // Neue TestSelector-Struktur erkennen (Objekt mit type, value usw.)
              if (typeof selector === 'object' && selector !== null && 'value' in selector) {
                const selectorType = selector.type;
                const selectorValue = selector.value;
                
                // Verwende die vom TestAnalyzer bereitgestellten Typen
                switch (selectorType.toLowerCase()) {
                  case 'css':
                    if (selectorValue.startsWith('#')) {
                      selectorTypes['ID-Selektor']++;
                    } else if (selectorValue.startsWith('.')) {
                      selectorTypes['Class-Selektor']++;
                    } else if (selectorValue.startsWith('[')) {
                      selectorTypes['Attribut-Selektor']++;
                    } else if (/^[a-z][a-z0-9]*$/i.test(selectorValue)) {
                      selectorTypes['Tag-Selektor']++;
                    } else if (selectorValue.includes(' ') || selectorValue.includes('>')) {
                      selectorTypes['CSS-Selektor']++;
                    } else {
                      selectorTypes['CSS-Selektor']++;
                    }
                    break;
                  case 'xpath':
                    selectorTypes['XPath']++;
                    break;
                  case 'text':
                    selectorTypes['Text-Selektor']++;
                    break;
                  case 'role':
                    selectorTypes['Role-Selektor']++;
                    break;
                  case 'testid':
                    selectorTypes['TestID-Selektor']++;
                    break;
                  default:
                    selectorTypes['Andere']++;
                }
              } 
              // Legacy-Format: Selektor ist ein direkter String
              else if (typeof selector === 'string') {
                if (selector.startsWith('#')) {
                  selectorTypes['ID-Selektor']++;
                } else if (selector.startsWith('.')) {
                  selectorTypes['Class-Selektor']++;
                } else if (selector.startsWith('[')) {
                  selectorTypes['Attribut-Selektor']++;
                } else if (selector.includes('/')) {
                  selectorTypes['XPath']++;
                } else if (selector.startsWith('text=')) {
                  selectorTypes['Text-Selektor']++;
                } else if (/^[a-z][a-z0-9]*$/i.test(selector)) {
                  selectorTypes['Tag-Selektor']++;
                } else if (selector.includes(' ') || selector.includes('>')) {
                  selectorTypes['CSS-Selektor']++;
                } else {
                  selectorTypes['Andere']++;
                }
              } else {
                console.warn('Unbekanntes Selektor-Format:', selector);
                selectorTypes['Andere']++;
              }
            } catch (error) {
              console.error('Fehler bei der Verarbeitung eines Selektors:', error, selector);
              selectorTypes['Andere']++;
            }
          });
        });
        
        // Leere Kategorien entfernen
        Object.keys(selectorTypes).forEach(key => {
          if (selectorTypes[key] === 0) delete selectorTypes[key];
        });
        
        console.log('Berechnete Selektortypen:', selectorTypes);
        return selectorTypes;
      }
      
      /**
       * Status in lesbaren Text formatieren
       */
      function formatStatus(status) {
        switch (status) {
          case 'success': return 'Gut';
          case 'warning': return 'Verbesserungswürdig';
          case 'danger': return 'Problematisch';
          case 'info': return 'Information';
          default: return status;
        }
      }
      
      /**
       * Funktionsbereiche formatieren
       */
      function formatFunctionalAreas(areas) {
        if (!areas || areas.length === 0) return '-';
        
        return areas.map(area => {
          return `<span class="badge bg-secondary me-1">${area}</span>`;
        }).join('');
      }
      
      /**
       * Komplexität formatieren und einstufen
       */
      function formatComplexity(value) {
        let badgeClass = '';
        let label = '';
        
        if (value < 5) {
          badgeClass = 'bg-success';
          label = 'Einfach';
        } else if (value < 10) {
          badgeClass = 'bg-info';
          label = 'Mittel';
        } else if (value < 15) {
          badgeClass = 'bg-warning';
          label = 'Komplex';
        } else {
          badgeClass = 'bg-danger';
          label = 'Sehr komplex';
        }
        
        return `<span class="badge ${badgeClass}">${label} (${value.toFixed(1)})</span>`;
      }
      
      /**
       * Analyse-Status anzeigen
       */
      function updateAnalysisStatus(type, message) {
        if (!analysisStatus) return;
        
        analysisStatus.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
      }
      
      /**
       * Lade-Indikator anzeigen/ausblenden
       */
      function showAnalysisLoading(isLoading) {
        if (!runAnalysisBtn || !analysisSpinner) return;
        
        if (isLoading) {
          runAnalysisBtn.disabled = true;
          analysisSpinner.classList.remove('d-none');
        } else {
          runAnalysisBtn.disabled = false;
          analysisSpinner.classList.add('d-none');
        }
      }
      
      // Entscheidungsmatrix-Funktionen
      let decisionMatrixChart = null;
      
      /**
       * Berechnet die Testqualität und Abdeckungsrelevanz für jeden Test
       * @param {Array} testMetadata - Array von Test-Metadaten
       * @param {Object} coverageMatrix - Abdeckungsmatrix-Daten
       * @returns {Array} - Array von Tests mit Bewertungen
       */
      function calculateTestDecisions(testMetadata, coverageMatrix) {
        // Matrix-Format umwandeln für einfacheren Zugriff
        const formattedMatrix = convertMatrixFormat(coverageMatrix);
        const gaps = identifyCoverageGaps(formattedMatrix);
        const gapAreas = gaps.map(gap => gap.area);
        
        // Tests bewerten
        return testMetadata.map(test => {
          // 1. Qualitätsscore berechnen (0-100)
          const selectorScore = Math.min(100, Math.max(0, (test.selectors && test.selectors.length > 0) ? 
            (100 - (test.selectorComplexity || 0) * 10) : 0));
          
          const assertionScore = Math.min(100, Math.max(0, (test.assertions && test.assertions.length > 0) ? 
            (test.assertions.length * 10) : 0));
            
          const stabilityScore = test.flakiness ? (100 - test.flakiness * 20) : 80;
          
          // Gewichteter Qualitätsscore
          const qualityScore = Math.round(
            (selectorScore * 0.4) + 
            (assertionScore * 0.4) + 
            (stabilityScore * 0.2)
          );
          
          // 2. Abdeckungsrelevanz berechnen (0-100)
          let coverageRelevance = 50; // Standard
          
          // Wenn Test einen Funktionsbereich abdeckt, der in den Lücken ist, ist er wichtiger
          if (test.functionArea && gapAreas.includes(test.functionArea)) {
            coverageRelevance += 40;
          }
          
          // Wenn es mehrere Tests für denselben Bereich gibt, ist die Relevanz geringer
          const similarTests = testMetadata.filter(t => 
            t.functionArea === test.functionArea && t.testId !== test.testId
          ).length;
          
          if (similarTests > 3) {
            coverageRelevance -= 30;
          } else if (similarTests > 0) {
            coverageRelevance -= similarTests * 10;
          }
          
          coverageRelevance = Math.min(100, Math.max(0, coverageRelevance));
          
          // 3. Empfehlung bestimmen
          let recommendation = '';
          let recommendationClass = '';
          
          if (qualityScore >= 70 && coverageRelevance >= 60) {
            recommendation = 'Beibehalten';
            recommendationClass = 'success';
          } else if (qualityScore < 50 && coverageRelevance < 40) {
            recommendation = 'Archivieren';
            recommendationClass = 'secondary';
          } else if (qualityScore < 60 && coverageRelevance >= 70) {
            recommendation = 'Optimieren';
            recommendationClass = 'warning';
          } else if (qualityScore < 50 && coverageRelevance >= 40 && similarTests > 2) {
            recommendation = 'Konsolidieren';
            recommendationClass = 'danger';
          } else {
            recommendation = 'Optimieren';
            recommendationClass = 'warning';
          }
          
          return {
            testId: test.testId,
            testName: test.testName || test.testId,
            functionArea: test.functionArea || 'Nicht angegeben',
            qualityScore,
            coverageRelevance,
            recommendation,
            recommendationClass
          };
        });
      }
      
      /**
       * Zeigt die Entscheidungsmatrix für Tests an
       * @param {Array} evaluatedTests - Array von bewerteten Tests
       */
      function displayDecisionMatrix(evaluatedTests) {
        if (!evaluatedTests || evaluatedTests.length === 0) {
          document.getElementById('decision-matrix-container').innerHTML = 
            '<div class="alert alert-warning">Keine Testdaten verfügbar für die Entscheidungsmatrix.</div>';
          document.getElementById('decision-table-body').innerHTML = 
            '<tr><td colspan="6" class="text-center">Keine Testdaten verfügbar.</td></tr>';
          return;
        }
        
        // 1. Scatter-Plot für die Matrix erstellen
        const container = document.getElementById('decision-matrix-container');
        // Alte Chart-Instanz zerstören, falls vorhanden
        if (decisionMatrixChart) {
          decisionMatrixChart.destroy();
        }
        
        // Canvas neu erstellen
        container.innerHTML = '';
        const canvas = document.createElement('canvas');
        canvas.id = 'decisionMatrixChart';
        container.appendChild(canvas);
        
        // Daten für den Chart aufbereiten
        const datasets = [];
        const recommendations = ['Beibehalten', 'Optimieren', 'Konsolidieren', 'Archivieren'];
        const colors = ['#28a745', '#ffc107', '#dc3545', '#6c757d'];
        
        // Gruppieren nach Empfehlung
        for (let i = 0; i < recommendations.length; i++) {
          const filteredTests = evaluatedTests.filter(test => test.recommendation === recommendations[i]);
          
          if (filteredTests.length > 0) {
            datasets.push({
              label: recommendations[i],
              data: filteredTests.map(test => ({
                x: test.qualityScore,
                y: test.coverageRelevance,
                testId: test.testId,
                testName: test.testName
              })),
              backgroundColor: colors[i],
              borderColor: colors[i],
              borderWidth: 1,
              pointRadius: 6,
              pointHoverRadius: 9
            });
          }
        }
        
        // Chart erstellen
        decisionMatrixChart = new Chart(canvas.getContext('2d'), {
          type: 'scatter',
          data: {
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: 'Test-Entscheidungsmatrix',
                font: { size: 16 }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const point = context.raw;
                    return `${point.testName} (Qualität: ${point.x}, Relevanz: ${point.y})`;
                  }
                }
              },
              legend: {
                position: 'bottom'
              }
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Qualitätsscore'
                },
                suggestedMin: 0,
                suggestedMax: 100
              },
              y: {
                title: {
                  display: true,
                  text: 'Abdeckungsrelevanz'
                },
                suggestedMin: 0,
                suggestedMax: 100
              }
            }
          }
        });
        
        // 2. Entscheidungstabelle füllen
        const tableBody = document.getElementById('decision-table-body');
        tableBody.innerHTML = '';
        
        evaluatedTests.forEach(test => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${test.testName}</td>
            <td>${test.functionArea}</td>
            <td>
              <div class="progress" style="height: 8px;">
                <div class="progress-bar ${getProgressClass(test.qualityScore)}" 
                     role="progressbar" style="width: ${test.qualityScore}%" 
                     aria-valuenow="${test.qualityScore}" aria-valuemin="0" aria-valuemax="100">
                </div>
              </div>
              <small class="text-muted">${test.qualityScore}%</small>
            </td>
            <td>
              <div class="progress" style="height: 8px;">
                <div class="progress-bar ${getProgressClass(test.coverageRelevance)}" 
                     role="progressbar" style="width: ${test.coverageRelevance}%" 
                     aria-valuenow="${test.coverageRelevance}" aria-valuemin="0" aria-valuemax="100">
                </div>
              </div>
              <small class="text-muted">${test.coverageRelevance}%</small>
            </td>
            <td><span class="badge bg-${test.recommendationClass}">${test.recommendation}</span></td>
            <td>
              <button class="btn btn-sm btn-outline-primary action-btn" data-action="view" data-test-id="${test.testId}">
                <i class="bi bi-eye"></i>
              </button>
              <button class="btn btn-sm btn-outline-secondary action-btn" data-action="${getRecommendedAction(test.recommendation)}" data-test-id="${test.testId}">
                ${getRecommendedActionIcon(test.recommendation)}
              </button>
            </td>
          `;
          tableBody.appendChild(row);
        });
        
        // Export-Button aktivieren
        document.getElementById('export-recommendations-btn').addEventListener('click', function() {
          exportDecisionRecommendations(evaluatedTests);
        });
      }
      
      /**
       * Gibt die passende Bootstrap-Klasse für den Fortschrittsbalken zurück
       */
      function getProgressClass(value) {
        if (value >= 70) return 'bg-success';
        if (value >= 50) return 'bg-warning';
        return 'bg-danger';
      }
      
      /**
       * Gibt die empfohlene Aktion für eine Empfehlung zurück
       */
      function getRecommendedAction(recommendation) {
        switch (recommendation) {
          case 'Beibehalten': return 'schedule';
          case 'Optimieren': return 'improve';
          case 'Konsolidieren': return 'merge';
          case 'Archivieren': return 'archive';
          default: return 'view';
        }
      }
      
      /**
       * Gibt das Icon für die empfohlene Aktion zurück
       */
      function getRecommendedActionIcon(recommendation) {
        switch (recommendation) {
          case 'Beibehalten': return '<i class="bi bi-calendar-check"></i>';
          case 'Optimieren': return '<i class="bi bi-tools"></i>';
          case 'Konsolidieren': return '<i class="bi bi-arrows-collapse"></i>';
          case 'Archivieren': return '<i class="bi bi-archive"></i>';
          default: return '<i class="bi bi-pencil"></i>';
        }
      }
      
      /**
       * Exportiert die Entscheidungsempfehlungen als CSV
       */
      function exportDecisionRecommendations(evaluatedTests) {
        if (!evaluatedTests || evaluatedTests.length === 0) {
          alert('Keine Daten zum Exportieren verfügbar.');
          return;
        }
        
        const headers = ['Test ID', 'Test Name', 'Funktionsbereich', 'Qualitätsscore', 'Abdeckungsrelevanz', 'Empfehlung'];
        let csvContent = headers.join(',') + '\n';
        
        evaluatedTests.forEach(test => {
          const row = [
            test.testId,
            '"' + test.testName + '"',
            '"' + test.functionArea + '"',
            test.qualityScore,
            test.coverageRelevance,
            '"' + test.recommendation + '"'
          ];
          csvContent += row.join(',') + '\n';
        });
        
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', 'test-empfehlungen.csv');
        link.style.visibility = 'hidden';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      // Erweiterte Event-Listener für Entscheidungsmatrix
      function setupExtendedEventListeners() {
        // Decision-Tab-Events
        document.getElementById('decision-tab').addEventListener('click', function() {
          if (window.dashboardData && window.dashboardData.testMetadata && window.dashboardData.coverageMatrix) {
            const evaluatedTests = calculateTestDecisions(
              window.dashboardData.testMetadata, 
              window.dashboardData.coverageMatrix
            );
            displayDecisionMatrix(evaluatedTests);
          }
        });
      }
      
      // Testkonsolidierungs-Funktionen
      let similarityChart = null;
      let currentTestClusters = [];
      
      /**
       * Findet ähnliche Tests, die zusammengeführt werden könnten
       * @param {Array} testMetadata - Array der Testmetadaten
       * @returns {Array} - Array von Test-Clustern
       */
      function findSimilarTests(testMetadata) {
        if (!testMetadata || testMetadata.length === 0) return [];
        
        const clusters = [];
        const processedTests = new Set();
        
        // Tests nach Funktionsbereich gruppieren
        const testsByArea = {};
        testMetadata.forEach(test => {
          const area = test.functionArea || 'Unbekannt';
          if (!testsByArea[area]) testsByArea[area] = [];
          testsByArea[area].push(test);
        });
        
        // Für jeden Funktionsbereich
        Object.keys(testsByArea).forEach(area => {
          const testsInArea = testsByArea[area];
          
          // Nur Bereiche mit mehreren Tests betrachten
          if (testsInArea.length <= 1) return;
          
          // Jedes Test-Paar in diesem Bereich analysieren
          for (let i = 0; i < testsInArea.length; i++) {
            if (processedTests.has(testsInArea[i].testId)) continue;
            
            const currentTest = testsInArea[i];
            const similarTests = [currentTest];
            
            // Ähnlichkeit mit anderen Tests prüfen
            for (let j = 0; j < testsInArea.length; j++) {
              if (i === j || processedTests.has(testsInArea[j].testId)) continue;
              
              const otherTest = testsInArea[j];
              const similarity = calculateTestSimilarity(currentTest, otherTest);
              
              if (similarity.total >= 0.6) { // 60% Ähnlichkeit als Schwellwert
                similarTests.push({
                  ...otherTest,
                  similarity
                });
              }
            }
            
            // Cluster nur erstellen, wenn mind. 2 ähnliche Tests gefunden wurden
            if (similarTests.length >= 2) {
              clusters.push({
                name: `${area} - Cluster ${clusters.length + 1}`,
                area,
                tests: similarTests,
                consolidationPotential: calculateConsolidationPotential(similarTests)
              });
              
              // Markiere alle Tests in diesem Cluster als verarbeitet
              similarTests.forEach(test => processedTests.add(test.testId));
            }
          }
        });
        
        // Nach Konsolidierungspotenzial sortieren (höchstes zuerst)
        return clusters.sort((a, b) => b.consolidationPotential - a.consolidationPotential);
      }
      
      /**
       * Berechnet die Ähnlichkeit zwischen zwei Tests
       * @param {Object} test1 - Erster Test
       * @param {Object} test2 - Zweiter Test
       * @returns {Object} - Ähnlichkeitswerte
       */
      function calculateTestSimilarity(test1, test2) {
        // 1. Selektor-Überlappung
        let selectorSimilarity = 0;
        if (test1.selectors && test2.selectors && test1.selectors.length > 0 && test2.selectors.length > 0) {
          const test1Selectors = new Set(test1.selectors.map(s => typeof s === 'string' ? s : JSON.stringify(s)));
          const test2Selectors = new Set(test2.selectors.map(s => typeof s === 'string' ? s : JSON.stringify(s)));
          
          let commonSelectors = 0;
          test1Selectors.forEach(selector => {
            if (test2Selectors.has(selector)) commonSelectors++;
          });
          
          const totalSelectors = test1Selectors.size + test2Selectors.size - commonSelectors;
          selectorSimilarity = totalSelectors > 0 ? commonSelectors / totalSelectors : 0;
        }
        
        // 2. Assertions-Überlappung
        let assertionSimilarity = 0;
        if (test1.assertions && test2.assertions && test1.assertions.length > 0 && test2.assertions.length > 0) {
          const test1Assertions = new Set(test1.assertions.map(a => typeof a === 'string' ? a : JSON.stringify(a)));
          const test2Assertions = new Set(test2.assertions.map(a => typeof a === 'string' ? a : JSON.stringify(a)));
          
          let commonAssertions = 0;
          test1Assertions.forEach(assertion => {
            if (test2Assertions.has(assertion)) commonAssertions++;
          });
          
          const totalAssertions = test1Assertions.size + test2Assertions.size - commonAssertions;
          assertionSimilarity = totalAssertions > 0 ? commonAssertions / totalAssertions : 0;
        }
        
        // 3. Testtyp-Übereinstimmung
        const typeSimilarity = test1.testType === test2.testType ? 1 : 0;
        
        // Gesamtsimilarität (gewichtet)
        const total = (selectorSimilarity * 0.5) + (assertionSimilarity * 0.3) + (typeSimilarity * 0.2);
        
        return {
          selectors: selectorSimilarity,
          assertions: assertionSimilarity,
          type: typeSimilarity,
          total
        };
      }
      
      /**
       * Berechnet das Konsolidierungspotenzial für einen Cluster
       */
      function calculateConsolidationPotential(testsInCluster) {
        if (testsInCluster.length <= 1) return 0;
        
        // 1. Anzahl der Tests im Cluster
        const clusterSizeScore = Math.min(1, (testsInCluster.length - 1) / 5); // Max 6 Tests
        
        // 2. Durchschnittliche Ähnlichkeit (ohne das erste Referenz-Test)
        let totalSimilarity = 0;
        let similarityCount = 0;
        
        for (let i = 1; i < testsInCluster.length; i++) {
          if (testsInCluster[i].similarity) {
            totalSimilarity += testsInCluster[i].similarity.total;
            similarityCount++;
          }
        }
        
        const avgSimilarity = similarityCount > 0 ? totalSimilarity / similarityCount : 0;
        
        // 3. Redundanz in Selektoren
        let selectorCount = 0;
        const uniqueSelectors = new Set();
        
        testsInCluster.forEach(test => {
          if (test.selectors) {
            selectorCount += test.selectors.length;
            test.selectors.forEach(selector => {
              uniqueSelectors.add(typeof selector === 'string' ? selector : JSON.stringify(selector));
            });
          }
        });
        
        const selectorRedundancyScore = selectorCount > 0 ? 
          1 - (uniqueSelectors.size / selectorCount) : 0;
        
        // Gewichtete Berechnung des Gesamtpotenzials (0-100)
        return Math.round((
          (clusterSizeScore * 30) + 
          (avgSimilarity * 40) + 
          (selectorRedundancyScore * 30)
        ) * 100);
      }
      
      /**
       * Generiert einen konsolidierten Testvorschlag
       */
      function generateMergedTestSuggestion(cluster) {
        if (!cluster || !cluster.tests || cluster.tests.length < 2) return null;
        
        const primaryTest = cluster.tests[0];
        const secondaryTests = cluster.tests.slice(1);
        
        // Sammle alle einzigartigen Selektoren
        const uniqueSelectors = new Map(); // selector string -> {selector, count}
        cluster.tests.forEach(test => {
          if (test.selectors) {
            test.selectors.forEach(selector => {
              const key = typeof selector === 'string' ? selector : JSON.stringify(selector);
              if (uniqueSelectors.has(key)) {
                uniqueSelectors.get(key).count++;
              } else {
                uniqueSelectors.set(key, { selector, count: 1 });
              }
            });
          }
        });
        
        // Sammle alle einzigartigen Assertions
        const uniqueAssertions = new Map(); // assertion string -> {assertion, count}
        cluster.tests.forEach(test => {
          if (test.assertions) {
            test.assertions.forEach(assertion => {
              const key = typeof assertion === 'string' ? assertion : JSON.stringify(assertion);
              if (uniqueAssertions.has(key)) {
                uniqueAssertions.get(key).count++;
              } else {
                uniqueAssertions.set(key, { assertion, count: 1 });
              }
            });
          }
        });
        
        // Erzeuge einen Vorschlag für einen konsolidierten Test
        return {
          testId: `merged_${primaryTest.testId}_${Date.now()}`,
          testName: `Konsolidiert: ${primaryTest.testName || primaryTest.testId}`,
          testType: primaryTest.testType,
          functionArea: primaryTest.functionArea,
          selectors: Array.from(uniqueSelectors.values())
            .sort((a, b) => b.count - a.count)
            .map(item => item.selector),
          assertions: Array.from(uniqueAssertions.values())
            .sort((a, b) => b.count - a.count)
            .map(item => item.assertion),
          steps: generateMergedSteps(cluster.tests),
          originalTests: cluster.tests.map(test => test.testId)
        };
      }
      
      /**
       * Generiert konsolidierte Testschritte
       */
      function generateMergedSteps(tests) {
        // Sammle alle Schritte aus allen Tests
        let allSteps = [];
        tests.forEach(test => {
          if (test.steps) {
            allSteps = allSteps.concat(test.steps.map(step => ({
              ...step,
              fromTest: test.testId
            })));
          }
        });
        
        // Entferne Duplikate und sortiere nach logischer Reihenfolge
        const uniqueSteps = [];
        const processedSteps = new Set();
        
        allSteps.forEach(step => {
          const stepKey = JSON.stringify({
            action: step.action,
            selector: step.selector,
            value: step.value
          });
          
          if (!processedSteps.has(stepKey)) {
            uniqueSteps.push(step);
            processedSteps.add(stepKey);
          }
        });
        
        // Versuche, die Schritte in eine logische Reihenfolge zu bringen
        // (z.B. Navigationen zuerst, dann Interaktionen, dann Assertions)
        return uniqueSteps.sort((a, b) => {
          // Navigationen zuerst
          if (a.action === 'navigate' && b.action !== 'navigate') return -1;
          if (b.action === 'navigate' && a.action !== 'navigate') return 1;
          
          // Klicks und Eingaben vor Assertions
          if (a.action === 'assert' && ['click', 'fill', 'type'].includes(b.action)) return 1;
          if (b.action === 'assert' && ['click', 'fill', 'type'].includes(a.action)) return -1;
          
          return 0;
        });
      }
      
      /**
       * Zeigt die Test-Cluster im UI an
       */
      function displayTestClusters(clusters) {
        const listContainer = document.getElementById('test-clusters-list');
        if (!listContainer) return;
        
        if (!clusters || clusters.length === 0) {
          listContainer.innerHTML = `
            <div class="alert alert-info">
              <p class="mb-0">Keine redundanten Tests gefunden.</p>
            </div>
          `;
          return;
        }
        
        listContainer.innerHTML = '';
        clusters.forEach((cluster, index) => {
          const listItem = document.createElement('button');
          listItem.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
          listItem.setAttribute('data-cluster-index', index);
          listItem.innerHTML = `
            <div>
              <h6 class="mb-1">${escapeHtml(cluster.name)}</h6>
              <small class="text-muted">${cluster.tests.length} Tests</small>
            </div>
            <span class="badge bg-${getConsolidationBadgeClass(cluster.consolidationPotential)}">
              ${cluster.consolidationPotential}%
            </span>
          `;
          
          listItem.addEventListener('click', () => {
            document.querySelectorAll('#test-clusters-list .list-group-item').forEach(el => {
              el.classList.remove('active');
            });
            listItem.classList.add('active');
            displayClusterDetails(cluster);
          });
          
          listContainer.appendChild(listItem);
        });
      }
      
      /**
       * Zeigt die Details eines Clusters an
       */
      function displayClusterDetails(cluster) {
        const detailsContainer = document.getElementById('consolidation-details');
        if (!detailsContainer) return;
        
        let html = `
          <h6>Funktionsbereich: ${escapeHtml(cluster.area)}</h6>
          <p>Konsolidierungspotenzial: <span class="badge bg-${getConsolidationBadgeClass(cluster.consolidationPotential)}">${cluster.consolidationPotential}%</span></p>
          <hr>
          <h6>Enthaltene Tests:</h6>
          <div class="table-responsive">
            <table class="table table-sm table-striped">
              <thead>
                <tr>
                  <th>Test</th>
                  <th>Ähnlichkeit</th>
                  <th>Selektoren</th>
                  <th>Assertions</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        cluster.tests.forEach((test, index) => {
          const similarity = index === 0 ? 'Referenz' : `${Math.round(test.similarity.total * 100)}%`;
          html += `
            <tr>
              <td>${escapeHtml(test.testName || test.testId)}</td>
              <td>${similarity}</td>
              <td>${test.selectors ? test.selectors.length : 0}</td>
              <td>${test.assertions ? test.assertions.length : 0}</td>
            </tr>
          `;
        });
        
        html += `
              </tbody>
            </table>
          </div>
        `;
        
        detailsContainer.innerHTML = html;
        
        // Ähnlichkeits-Chart erstellen
        displaySimilarityChart(cluster);
        
        // Konsolidierten Test generieren
        const mergedTest = generateMergedTestSuggestion(cluster);
        if (mergedTest) {
          displayMergedTestPreview(mergedTest);
        }
      }
      
      /**
       * Zeigt einen Chart mit der Ähnlichkeitsverteilung an
       */
      function displaySimilarityChart(cluster) {
        const container = document.getElementById('similarity-chart-container');
        if (!container) return;
        
        // Prüfen, ob Chart.js verfügbar ist
        if (typeof Chart === 'undefined') {
          container.innerHTML = '<div class="alert alert-warning">Chart.js ist nicht verfügbar. Diagramm kann nicht angezeigt werden.</div>';
          return;
        }
        
        try {
          // Alte Chart-Instanz zerstören, falls vorhanden
          if (similarityChart) {
            similarityChart.destroy();
          }
          
          // Canvas neu erstellen
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'similarityChart';
          container.appendChild(canvas);
          
          // Daten für den Chart aufbereiten
          const tests = cluster.tests.slice(1); // Ohne Referenztest
          if (tests.length === 0) {
            container.innerHTML = '<div class="alert alert-info">Keine Ähnlichkeitsdaten verfügbar.</div>';
            return;
          }
          
          const labels = tests.map(test => {
            const name = test.testName || test.testId || 'Unbekannter Test';
            // Zu lange Namen kürzen
            return name.length > 15 ? name.substring(0, 12) + '...' : name;
          });
          
          const data = {
            labels,
            datasets: [{
              label: 'Selektoren',
              backgroundColor: 'rgba(54, 162, 235, 0.5)',
              borderColor: 'rgb(54, 162, 235)',
              borderWidth: 1,
              data: tests.map(test => Math.round(test.similarity.selectors * 100))
            }, {
              label: 'Assertions',
              backgroundColor: 'rgba(255, 99, 132, 0.5)',
              borderColor: 'rgb(255, 99, 132)',
              borderWidth: 1,
              data: tests.map(test => Math.round(test.similarity.assertions * 100))
            }, {
              label: 'Gesamt',
              backgroundColor: 'rgba(75, 192, 192, 0.5)',
              borderColor: 'rgb(75, 192, 192)',
              borderWidth: 1,
              data: tests.map(test => Math.round(test.similarity.total * 100))
            }]
          };
          
          // Chart erstellen
          similarityChart = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: {
                  display: true,
                  text: 'Ähnlichkeit zum Referenztest (%)',
                  font: { size: 14 }
                },
                legend: {
                  position: 'bottom'
                },
                tooltip: {
                  callbacks: {
                    title: function(tooltipItems) {
                      const index = tooltipItems[0].dataIndex;
                      const fullName = tests[index].testName || tests[index].testId;
                      return fullName; // Vollständiger Name im Tooltip
                    }
                  }
                }
              },
              scales: {
                y: {
                  min: 0,
                  max: 100,
                  title: {
                    display: true,
                    text: 'Ähnlichkeit (%)'
                  }
                }
              }
            }
          });
        } catch (error) {
          console.error('Fehler beim Erstellen des Ähnlichkeitsdiagramms:', error);
          container.innerHTML = `<div class="alert alert-danger">Fehler beim Erstellen des Diagramms: ${error.message}</div>`;
        }
      }
      
      /**
       * Zeigt eine Vorschau des zusammengeführten Tests an
       */
      function displayMergedTestPreview(mergedTest) {
        const container = document.getElementById('merge-recommendation');
        const codePreview = document.getElementById('merged-test-preview');
        const copyBtn = document.getElementById('copy-merged-test-btn');
        const applyBtn = document.getElementById('apply-merge-btn');
        
        if (!container || !codePreview || !copyBtn || !applyBtn) {
          console.error('Ein oder mehrere erforderliche UI-Elemente fehlen');
          return;
        }
        
        // Einfache Test-Vorschau generieren
        const preview = generateTestPreview(mergedTest);
        codePreview.textContent = preview;
        
        // Aktionen aktivieren
        container.classList.remove('d-none');
        
        // Bestehende Event-Listener entfernen, um Mehrfachbindungen zu vermeiden
        const newCopyBtn = copyBtn.cloneNode(true);
        copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);
        
        const newApplyBtn = applyBtn.cloneNode(true);
        applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
        
        // Neue Event-Listener hinzufügen
        newCopyBtn.addEventListener('click', function(e) {
          e.preventDefault();
          try {
            navigator.clipboard.writeText(preview).then(() => {
              // Kurzes visuelles Feedback statt Alert
              const originalText = newCopyBtn.innerHTML;
              newCopyBtn.innerHTML = '<i class="bi bi-check"></i> Kopiert!';
              newCopyBtn.classList.add('btn-success');
              newCopyBtn.classList.remove('btn-outline-secondary');
              
              setTimeout(() => {
                newCopyBtn.innerHTML = originalText;
                newCopyBtn.classList.remove('btn-success');
                newCopyBtn.classList.add('btn-outline-secondary');
              }, 1500);
            }).catch(err => {
              console.error('Fehler beim Kopieren:', err);
              alert('Konnte nicht in die Zwischenablage kopieren: ' + err.message);
            });
          } catch (err) {
            console.error('Fehler beim Kopieren:', err);
            // Fallback für ältere Browser
            const textarea = document.createElement('textarea');
            textarea.value = preview;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            alert('Konsolidierter Test wurde in die Zwischenablage kopiert.');
          }
        });
        
        newApplyBtn.addEventListener('click', function(e) {
          e.preventDefault();
          alert('Diese Funktion wird in einer zukünftigen Version implementiert.');
        });
      }
      
      /**
       * Generiert eine Code-Vorschau für einen Test
       */
      function generateTestPreview(test) {
        let code = `// Konsolidierter Test: ${test.testName}\n`;
        code += `// Kombiniert aus: ${test.originalTests.join(', ')}\n`;
        code += `// Funktionsbereich: ${test.functionArea}\n\n`;
        
        code += `test('${test.testName}', async ({ page }) => {\n`;
        
        // Schritte generieren
        if (test.steps && test.steps.length > 0) {
          test.steps.forEach(step => {
            switch (step.action) {
              case 'navigate':
                code += `  await page.goto('${step.value}');\n`;
                break;
              case 'click':
                code += `  await page.click('${step.selector}');\n`;
                break;
              case 'fill':
                code += `  await page.fill('${step.selector}', '${step.value}');\n`;
                break;
              case 'type':
                code += `  await page.type('${step.selector}', '${step.value}');\n`;
                break;
              case 'assert':
                if (step.assertion === 'visible') {
                  code += `  await expect(page.locator('${step.selector}')).toBeVisible();\n`;
                } else if (step.assertion === 'text') {
                  code += `  await expect(page.locator('${step.selector}')).toHaveText('${step.value}');\n`;
                } else {
                  code += `  // Assertion: ${step.assertion}\n`;
                }
                break;
              default:
                code += `  // Unbekannte Aktion: ${step.action}\n`;
            }
          });
        } else {
          // Keine Schritte, generiere aus Selektoren und Assertions
          if (test.selectors && test.selectors.length > 0) {
            test.selectors.forEach(selector => {
              const sel = typeof selector === 'string' ? selector : JSON.stringify(selector);
              code += `  await page.locator('${sel}').click();\n`;
            });
          }
          
          if (test.assertions && test.assertions.length > 0) {
            test.assertions.forEach(assertion => {
              const assert = typeof assertion === 'string' ? assertion : JSON.stringify(assertion);
              code += `  // Assertion: ${assert}\n`;
            });
          }
        }
        
        code += '});\n';
        return code;
      }
      
      /**
       * Hilfsfunktion, um HTML zu escapen
       */
      function escapeHtml(unsafe) {
        return unsafe
          .toString()
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      
      /**
       * Hilfsfunktion, um Badge-Klasse für Konsolidierungspotenzial zu erhalten
       */
      function getConsolidationBadgeClass(potential) {
        if (potential >= 80) return 'danger';
        if (potential >= 60) return 'warning';
        if (potential >= 40) return 'info';
        return 'secondary';
      }
      
      // Erweiterte Event-Listener für Tabs und Funktionen
      function setupExtendedEventListeners() {
        // Decision-Tab-Events
        const decisionTab = document.getElementById('decision-tab');
        if (decisionTab) {
          decisionTab.addEventListener('click', function() {
            if (window.dashboardData && window.dashboardData.testMetadata && window.dashboardData.coverageMatrix) {
              const evaluatedTests = calculateTestDecisions(
                window.dashboardData.testMetadata, 
                window.dashboardData.coverageMatrix
              );
              displayDecisionMatrix(evaluatedTests);
            }
          });
        }
      }
      
      // Separate Funktion für die Konsolidierungsfunktionen-Listener
      function setupConsolidationListeners() {
        // "Redundanzen finden"-Button
        const findRedundantBtn = document.getElementById('find-redundant-tests-btn');
        if (findRedundantBtn) {
          findRedundantBtn.addEventListener('click', function() {
            if (window.dashboardData && window.dashboardData.testMetadata) {
              currentTestClusters = findSimilarTests(window.dashboardData.testMetadata);
              displayTestClusters(currentTestClusters);
            } else {
              alert('Führen Sie zuerst eine Analyse durch, um Testdaten zu laden.');
            }
          });
        }
      }
      
      // Event-Listener einrichten
      setupExtendedEventListeners();
      
      // Nach dem DOM-Load die Konsolidierungs- und Portfolio-Listener einrichten
      document.addEventListener('DOMContentLoaded', function() {
        setupConsolidationListeners();
        setupPortfolioListeners();
      });
      
      // Zusätzlich die Konsolidierungs-Listener beim Öffnen des Tabs einrichten
      document.getElementById('consolidate-tab')?.addEventListener('click', function() {
        // Etwas verzögert ausführen, um sicherzustellen, dass alle Elemente gerendert sind
        setTimeout(() => {
          setupConsolidationListeners();
        }, 100);
      });
      
      // Test-Portfolio-Listener beim Öffnen des Tabs einrichten
      document.getElementById('portfolio-tab')?.addEventListener('click', function() {
        // Etwas verzögert ausführen, um sicherzustellen, dass alle Elemente gerendert sind
        setTimeout(() => {
          setupPortfolioListeners();
          loadTestPortfolio();
        }, 100);
      });
      
      //------------------------------------------------------
      // Test-Portfolio-Dokumentation Funktionen
      //------------------------------------------------------
      
      // Portfolio-Charts
      let documentationStatusChart = null;
      let areaDistributionChart = null;
      let typeDistributionChart = null;
      
      // Portfolio-Datenstruktur
      let testPortfolioData = [];
      let currentPortfolioFilter = 'all';
      let currentPortfolioSort = 'name';
      let selectedTestId = null;
      
      /**
       * Lädt die Test-Portfolio-Daten
       */
      function loadTestPortfolio() {
        const portfolioTable = document.getElementById('test-portfolio-table');
        if (!portfolioTable) return;
        
        // Lade-Indikator anzeigen
        portfolioTable.querySelector('tbody').innerHTML = `
          <tr>
            <td colspan="6" class="text-center p-3">
              <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
              Test-Katalog wird geladen...
            </td>
          </tr>
        `;
        
        // Verwende die bereits geladenen Testmetadaten, falls vorhanden
        if (window.dashboardData && window.dashboardData.testMetadata) {
          // Erweitere die Testmetadaten um Dokumentationsinformationen
          testPortfolioData = enrichTestsWithDocumentation(window.dashboardData.testMetadata);
          displayTestPortfolio(testPortfolioData);
          updatePortfolioCharts(testPortfolioData);
        } else {
          // Keine Testdaten vorhanden, zeige Hinweis
          portfolioTable.querySelector('tbody').innerHTML = `
            <tr>
              <td colspan="6" class="text-center p-3">
                <div class="alert alert-warning mb-0">
                  <i class="bi bi-exclamation-triangle me-2"></i>
                  Keine Testdaten gefunden. Führen Sie zuerst eine Test-Analyse durch.
                </div>
              </td>
            </tr>
          `;
        }
      }
      
      /**
       * Erweitert Testdaten um Dokumentationsinformationen
       */
      function enrichTestsWithDocumentation(testMetadata) {
        if (!testMetadata) return [];
        
        // Lade gespeicherte Dokumentation aus localStorage
        let savedDocs = {};
        try {
          const savedDocsStr = localStorage.getItem('test_documentation');
          if (savedDocsStr) {
            savedDocs = JSON.parse(savedDocsStr);
          }
        } catch (e) {
          console.error('Fehler beim Laden der gespeicherten Dokumentation:', e);
        }
        
        // Erweitere Testmetadaten
        return testMetadata.map(test => {
          const testId = test.testId || test.id || '';
          const savedDoc = savedDocs[testId] || {};
          
          return {
            ...test,
            documentation: {
              exists: !!savedDoc.description,
              description: savedDoc.description || '',
              author: savedDoc.author || '',
              lastUpdated: savedDoc.lastUpdated || '',
              notes: savedDoc.notes || '',
              tags: savedDoc.tags || []
            },
            qualityScore: calculateTestQualityScore(test)
          };
        });
      }
      
      /**
       * Berechnet einen Qualitätsscore für einen Test
       */
      function calculateTestQualityScore(test) {
        if (!test) return 0;
        
        let score = 50; // Standardwert
        
        // Selektorkomplexität bewerten
        if (test.selectors && test.selectors.length > 0) {
          const complexityPenalty = Math.min(20, test.selectors.length * 2);
          score -= complexityPenalty;
        }
        
        // Assertions bewerten
        if (test.assertions && test.assertions.length > 0) {
          const assertionBonus = Math.min(15, test.assertions.length * 3);
          score += assertionBonus;
        }
        
        // Testtyp bewerten
        if (test.testType === 'e2e') {
          score += 10;
        } else if (test.testType === 'component') {
          score += 5;
        }
        
        // Dokumentation bewerten
        if (test.documentation && test.documentation.exists) {
          score += 15;
        }
        
        // Sicherstellen, dass der Score im Bereich 0-100 liegt
        return Math.max(0, Math.min(100, score));
      }
      
      /**
       * Zeigt die Test-Portfolio-Daten in der Tabelle an
       */
      function displayTestPortfolio(data) {
        const portfolioTable = document.getElementById('test-portfolio-table');
        if (!portfolioTable) return;
        
        // Filtern und sortieren der Daten
        const filteredData = filterPortfolioData(data);
        const sortedData = sortPortfolioData(filteredData);
        
        // Tabelle aktualisieren
        if (sortedData.length === 0) {
          portfolioTable.querySelector('tbody').innerHTML = `
            <tr>
              <td colspan="6" class="text-center p-3">
                Keine Tests gefunden. Passen Sie die Filter an oder führen Sie eine Test-Analyse durch.
              </td>
            </tr>
          `;
          return;
        }
        
        // Zähler für dokumentierte/undokumentierte Tests
        let documentedCount = 0;
        let undocumentedCount = 0;
        
        // Zeilen für jede Test-Datei erstellen
        const rows = sortedData.map(test => {
          const testId = test.testId || test.id || Math.random().toString(36).substring(2, 9);
          const testName = test.testName || test.name || 'Unbenannter Test';
          const functionArea = test.functionArea || test.area || 'Unbekannt';
          const testType = test.testType || 'Unbekannt';
          const qualityScore = test.qualityScore || 0;
          const isDocumented = test.documentation && test.documentation.exists;
          
          // Zähler aktualisieren
          if (isDocumented) documentedCount++;
          else undocumentedCount++;
          
          // Qualitätsscore-Farbe bestimmen
          let qualityClass = 'bg-danger';
          if (qualityScore >= 70) qualityClass = 'bg-success';
          else if (qualityScore >= 40) qualityClass = 'bg-warning';
          
          return `
            <tr data-test-id="${testId}" class="test-row">
              <td><strong>${testName}</strong></td>
              <td>${functionArea}</td>
              <td><span class="badge bg-secondary">${testType}</span></td>
              <td>
                <div class="progress" style="height: 6px;">
                  <div class="progress-bar ${qualityClass}" role="progressbar" style="width: ${qualityScore}%" 
                       aria-valuenow="${qualityScore}" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
                <small class="d-block mt-1">${qualityScore}/100</small>
              </td>
              <td>
                ${isDocumented ? 
                  `<span class="badge bg-success"><i class="bi bi-check-circle"></i></span>` : 
                  `<span class="badge bg-danger"><i class="bi bi-exclamation-circle"></i></span>`
                }
              </td>
              <td>
                <div class="btn-group btn-group-sm">
                  <button class="btn btn-outline-primary view-doc-btn" data-test-id="${testId}">
                    <i class="bi bi-eye"></i>
                  </button>
                  <button class="btn btn-outline-secondary edit-doc-btn" data-test-id="${testId}">
                    <i class="bi bi-pencil"></i>
                  </button>
                </div>
              </td>
            </tr>
          `;
        }).join('');
        
        portfolioTable.querySelector('tbody').innerHTML = rows;
        
        // Zusammenfassung aktualisieren
        document.getElementById('portfolio-summary').textContent = `${sortedData.length} Tests im Katalog`;
        document.getElementById('documented-count').textContent = documentedCount;
        document.getElementById('undocumented-count').textContent = undocumentedCount;
        
        // Event-Listener für Tabellenzellen hinzufügen
        setupTableRowListeners();
      }
      
      /**
       * Fügt Event-Listener zu den Tabellenzeilen hinzu
       */
      function setupTableRowListeners() {
        // Ansicht-Buttons
        document.querySelectorAll('.view-doc-btn').forEach(btn => {
          btn.addEventListener('click', function(e) {
            e.preventDefault();
            const testId = this.getAttribute('data-test-id');
            showTestDocumentation(testId);
          });
        });
        
        // Bearbeiten-Buttons
        document.querySelectorAll('.edit-doc-btn').forEach(btn => {
          btn.addEventListener('click', function(e) {
            e.preventDefault();
            const testId = this.getAttribute('data-test-id');
            editTestDocumentation(testId);
          });
        });
        
        // Zeilen-Klick
        document.querySelectorAll('.test-row').forEach(row => {
          row.addEventListener('click', function(e) {
            if (e.target.closest('.btn')) return; // Ignorieren, wenn auf einen Button geklickt wurde
            const testId = this.getAttribute('data-test-id');
            showTestMetrics(testId);
          });
        });
      }
      
      /**
       * Filtert die Portfolio-Daten basierend auf dem aktuellen Filter
       */
      function filterPortfolioData(data) {
        if (!data || currentPortfolioFilter === 'all') return data;
        
        return data.filter(test => {
          if (currentPortfolioFilter === 'documented') {
            return test.documentation && test.documentation.exists;
          } else if (currentPortfolioFilter === 'undocumented') {
            return !test.documentation || !test.documentation.exists;
          }
          return true;
        });
      }
      
      /**
       * Sortiert die Portfolio-Daten basierend auf der aktuellen Sortierung
       */
      function sortPortfolioData(data) {
        if (!data) return [];
        
        return [...data].sort((a, b) => {
          switch (currentPortfolioSort) {
            case 'name':
              return (a.testName || a.name || '').localeCompare(b.testName || b.name || '');
            case 'area':
              return (a.functionArea || a.area || '').localeCompare(b.functionArea || b.area || '');
            case 'type':
              return (a.testType || '').localeCompare(b.testType || '');
            case 'quality':
              return (b.qualityScore || 0) - (a.qualityScore || 0);
            default:
              return 0;
          }
        });
      }
      
      /**
       * Wendet den aktuellen Filter auf die Portfoliodaten an
       */
      function applyPortfolioFilter() {
        displayTestPortfolio(testPortfolioData);
      }
      
      /**
       * Wendet die aktuelle Sortierung auf die Portfoliodaten an
       */
      function applyPortfolioSort() {
        displayTestPortfolio(testPortfolioData);
      }
      
      /**
       * Richtet alle Event-Listener für das Test-Portfolio ein
       */
      function setupPortfolioListeners() {
        // Filter-Optionen (mit Clean-Up für Event-Listener)
        document.querySelectorAll('.filter-option').forEach(option => {
          const newOption = option.cloneNode(true);
          option.parentNode.replaceChild(newOption, option);
          newOption.addEventListener('click', function(e) {
            e.preventDefault();
            currentPortfolioFilter = this.getAttribute('data-filter');
            applyPortfolioFilter();
          });
        });
        
        // Sortier-Optionen (mit Clean-Up für Event-Listener)
        document.querySelectorAll('.sort-option').forEach(option => {
          const newOption = option.cloneNode(true);
          option.parentNode.replaceChild(newOption, option);
          newOption.addEventListener('click', function(e) {
            e.preventDefault();
            currentPortfolioSort = this.getAttribute('data-sort');
            applyPortfolioSort();
          });
        });
        
        // Export-Button
        const exportBtn = document.getElementById('export-portfolio-btn');
        if (exportBtn) {
          const newExportBtn = exportBtn.cloneNode(true);
          exportBtn.parentNode.replaceChild(newExportBtn, exportBtn);
          newExportBtn.addEventListener('click', exportTestPortfolio);
        }
        
        // Bericht-Button
        const reportBtn = document.getElementById('generate-report-btn');
        if (reportBtn) {
          const newReportBtn = reportBtn.cloneNode(true);
          reportBtn.parentNode.replaceChild(newReportBtn, reportBtn);
          newReportBtn.addEventListener('click', generatePortfolioReport);
        }
        
        // Formular-Events für die Dokumentation
        const docForm = document.getElementById('documentation-form');
        if (docForm) {
          docForm.onsubmit = function(e) {
            e.preventDefault();
            saveTestDocumentation();
          };
        }
        
        // Abbrechen-Button für das Dokumentations-Formular
        const cancelBtn = document.getElementById('cancel-doc-btn');
        if (cancelBtn) {
          const newCancelBtn = cancelBtn.cloneNode(true);
          cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
          newCancelBtn.addEventListener('click', function() {
            hideDocumentationForm();
            showTestDocumentation(selectedTestId);
          });
        }
        
        // Tag-Hinzufügen-Button
        const addTagBtn = document.getElementById('addTagBtn');
        if (addTagBtn) {
          const newAddTagBtn = addTagBtn.cloneNode(true);
          addTagBtn.parentNode.replaceChild(newAddTagBtn, addTagBtn);
          newAddTagBtn.addEventListener('click', addDocumentationTag);
        }
      }
      
      /**
       * Zeigt die Test-Dokumentation für einen bestimmten Test an
       */
      function showTestDocumentation(testId) {
        if (!testId) {
          logDebug('showTestDocumentation: Keine Test-ID übergeben');
          return;
        }
        selectedTestId = testId;
        logDebug(`showTestDocumentation: Zeige Dokumentation für Test ${testId}`);
        
        // Test-Daten finden
        const test = testPortfolioData.find(t => (t.testId || t.id) === testId);
        if (!test) {
          logDebug(`showTestDocumentation: Test mit ID ${testId} nicht gefunden`);
          return;
        }
        
        logDebug('Test-Objekt gefunden:', test);
        
        // Dokumentations-Ansicht und Formular aktualisieren
        const docView = document.getElementById('test-documentation-view');
        const docEdit = document.getElementById('test-documentation-edit');
        
        if (!docView || !docEdit) {
          logDebug('showTestDocumentation: DOM-Elemente nicht gefunden', { docView: !!docView, docEdit: !!docEdit });
          return;
        }
        
        // Dokumentations-Ansicht zeigen, Formular ausblenden
        docView.classList.remove('d-none');
        docEdit.classList.add('d-none');
        
        // Testmetriken anzeigen
        showTestMetrics(testId);
        
        // Prüfen, ob Dokumentation existiert
        if (test.documentation && test.documentation.exists) {
          // Dokumentation anzeigen
          docView.innerHTML = `
            <h5>${test.testName || test.name || 'Unbenannter Test'}</h5>
            <hr>
            <div class="mb-3">
              <p>${test.documentation.description || 'Keine Beschreibung vorhanden.'}</p>
            </div>
            
            <div class="row mb-3">
              <div class="col-md-6">
                <small class="text-muted">Autor:</small>
                <p class="mb-2">${test.documentation.author || 'Nicht angegeben'}</p>
              </div>
              <div class="col-md-6">
                <small class="text-muted">Zuletzt aktualisiert:</small>
                <p class="mb-2">${test.documentation.lastUpdated || 'Nicht angegeben'}</p>
              </div>
            </div>
            
            ${test.documentation.notes ? `
              <div class="mb-3">
                <small class="text-muted">Hinweise & Wartungsanforderungen:</small>
                <p class="mb-2">${test.documentation.notes}</p>
              </div>
            ` : ''}
            
            ${test.documentation.tags && test.documentation.tags.length > 0 ? `
              <div class="mb-3">
                <small class="text-muted">Tags:</small>
                <div>
                  ${test.documentation.tags.map(tag => 
                    `<span class="badge bg-light text-dark me-1">${tag}</span>`
                  ).join('')}
                </div>
              </div>
            ` : ''}
            
            <div class="mt-4">
              <button class="btn btn-sm btn-outline-secondary edit-doc-btn" data-test-id="${testId}">
                <i class="bi bi-pencil"></i> Dokumentation bearbeiten
              </button>
            </div>
          `;
          
          // Event-Listener für Bearbeiten-Button hinzufügen
          docView.querySelector('.edit-doc-btn').addEventListener('click', function() {
            editTestDocumentation(testId);
          });
        } else {
          // Keine Dokumentation vorhanden, Aufforderung zum Erstellen anzeigen
          docView.innerHTML = `
            <div class="alert alert-warning">
              <h5 class="alert-heading">${test.testName || test.name || 'Unbenannter Test'}</h5>
              <p>Dieser Test hat noch keine Dokumentation.</p>
              <hr>
              <button class="btn btn-primary create-doc-btn" data-test-id="${testId}">
                <i class="bi bi-file-earmark-plus"></i> Dokumentation erstellen
              </button>
            </div>
          `;
          
          // Event-Listener für Erstellen-Button hinzufügen
          docView.querySelector('.create-doc-btn').addEventListener('click', function() {
            editTestDocumentation(testId);
          });
        }
      }
      
      /**
       * Zeigt das Formular zur Bearbeitung der Test-Dokumentation
       */
      function editTestDocumentation(testId) {
        if (!testId) return;
        selectedTestId = testId;
        
        // Test-Daten finden
        const test = testPortfolioData.find(t => (t.testId || t.id) === testId);
        if (!test) return;
        
        const docView = document.getElementById('test-documentation-view');
        const docEdit = document.getElementById('test-documentation-edit');
        const docForm = document.getElementById('documentation-form');
        
        if (!docView || !docEdit || !docForm) return;
        
        // Dokumentations-Formular zeigen, Ansicht ausblenden
        docView.classList.add('d-none');
        docEdit.classList.remove('d-none');
        
        // Formular mit vorhandenen Daten füllen
        document.getElementById('docTestName').value = test.testName || test.name || 'Unbenannter Test';
        document.getElementById('docDescription').value = test.documentation ? (test.documentation.description || '') : '';
        document.getElementById('docAuthor').value = test.documentation ? (test.documentation.author || '') : '';
        document.getElementById('docLastUpdated').value = test.documentation ? (test.documentation.lastUpdated || new Date().toISOString().split('T')[0]) : new Date().toISOString().split('T')[0];
        document.getElementById('docNotes').value = test.documentation ? (test.documentation.notes || '') : '';
        
        // Tags anzeigen
        const tagsContainer = document.getElementById('docTagsContainer');
        tagsContainer.innerHTML = '';
        
        if (test.documentation && test.documentation.tags && test.documentation.tags.length > 0) {
          test.documentation.tags.forEach(tag => {
            addTagToContainer(tag);
          });
        }
        
        // Tag-Input leeren
        document.getElementById('docTagInput').value = '';
      }
      
      /**
       * Fügt einen Tag zum Tag-Container hinzu
       */
      function addDocumentationTag() {
        const tagInput = document.getElementById('docTagInput');
        if (!tagInput) return;
        
        const tagValue = tagInput.value.trim();
        if (!tagValue) return;
        
        addTagToContainer(tagValue);
        tagInput.value = '';
      }
      
      /**
       * Fügt einen Tag zum Container hinzu
       */
      function addTagToContainer(tag) {
        const tagsContainer = document.getElementById('docTagsContainer');
        if (!tagsContainer) return;
        
        const tagElement = document.createElement('span');
        tagElement.className = 'badge bg-light text-dark me-1 mb-1 d-inline-flex align-items-center';
        tagElement.innerHTML = `
          ${tag}
          <button type="button" class="btn-close btn-close-sm ms-2" style="font-size: 0.5rem;"></button>
        `;
        
        // Event-Listener für Löschen-Button
        tagElement.querySelector('.btn-close').addEventListener('click', function() {
          tagsContainer.removeChild(tagElement);
        });
        
        tagsContainer.appendChild(tagElement);
      }
      
      /**
       * Blendet das Dokumentationsformular aus
       */
      function hideDocumentationForm() {
        const docView = document.getElementById('test-documentation-view');
        const docEdit = document.getElementById('test-documentation-edit');
        
        if (docView && docEdit) {
          docView.classList.remove('d-none');
          docEdit.classList.add('d-none');
        }
      }
      
      /**
       * Speichert die Test-Dokumentation
       */
      function saveTestDocumentation() {
        if (!selectedTestId) {
          logDebug('saveTestDocumentation: Keine Test-ID ausgewählt');
          return;
        }
        
        logDebug(`saveTestDocumentation: Speichere Dokumentation für Test ${selectedTestId}`);
        
        // Werte aus dem Formular auslesen
        const description = document.getElementById('docDescription')?.value || '';
        const author = document.getElementById('docAuthor')?.value || '';
        const lastUpdated = document.getElementById('docLastUpdated')?.value || new Date().toISOString().split('T')[0];
        const notes = document.getElementById('docNotes')?.value || '';
        
        logDebug('Formularwerte:', { description: description.slice(0, 20) + '...', author, lastUpdated, notes: notes.slice(0, 20) + '...' });
        
        // Tags sammeln
        const tagsContainer = document.getElementById('docTagsContainer');
        if (!tagsContainer) {
          logDebug('saveTestDocumentation: Tag-Container nicht gefunden');
          return;
        }
        
        const tags = [];
        tagsContainer.querySelectorAll('.badge').forEach(badge => {
          // Lösch-Button-Text aus dem Tag-Text entfernen
          let tagText = badge.textContent.trim();
          if (tagText) {
            // Entferne möglichen 'x' Text vom Schließen-Button
            tagText = tagText.replace(/\s*[×x]\s*$/i, '').trim();
            tags.push(tagText);
          }
        });
        
        logDebug(`saveTestDocumentation: ${tags.length} Tags gefunden`, tags);
        
        // Test-Objekt aktualisieren
        const testIndex = testPortfolioData.findIndex(t => (t.testId || t.id) === selectedTestId);
        if (testIndex !== -1) {
          logDebug(`saveTestDocumentation: Test an Index ${testIndex} gefunden, aktualisiere Dokumentation`);
          
          const documentation = {
            exists: !!description,
            description,
            author,
            lastUpdated,
            notes,
            tags
          };
          
          testPortfolioData[testIndex].documentation = documentation;
          logDebug('Documentation-Objekt erstellt:', documentation);
          
          // Qualitätsscore aktualisieren
          try {
            const oldScore = testPortfolioData[testIndex].qualityScore;
            testPortfolioData[testIndex].qualityScore = calculateTestQualityScore(testPortfolioData[testIndex]);
            logDebug(`Qualitätsscore aktualisiert: ${oldScore} -> ${testPortfolioData[testIndex].qualityScore}`);
          } catch (error) {
            logDebug('Fehler beim Aktualisieren des Qualitätsscores:', error);
            // Fallback zu einem Standardwert, falls die Berechnung fehlschlägt
            testPortfolioData[testIndex].qualityScore = testPortfolioData[testIndex].qualityScore || 50;
          }
        } else {
          logDebug(`saveTestDocumentation: Test mit ID ${selectedTestId} nicht gefunden`);
        }
        
        // Dokumentation in localStorage speichern
        saveDocumentationToStorage();
        
        // Aktualisierte Ansicht anzeigen
        displayTestPortfolio(testPortfolioData);
        showTestDocumentation(selectedTestId);
        updatePortfolioCharts(testPortfolioData);
      }
      
      /**
       * Speichert alle Dokumentationen im localStorage
       */
      function saveDocumentationToStorage() {
        logDebug('saveDocumentationToStorage: Starte Speichervorgang');
        
        if (!testPortfolioData || !Array.isArray(testPortfolioData)) {
          logDebug('saveDocumentationToStorage: Keine gültigen Testdaten vorhanden');
          return;
        }
        
        const documentationData = {};
        let savedCount = 0;
        
        testPortfolioData.forEach(test => {
          if (test && test.documentation && test.documentation.exists) {
            const testId = test.testId || test.id;
            if (!testId) {
              logDebug('Test ohne gültige ID gefunden:', test);
              return;
            }
            
            documentationData[testId] = {
              description: test.documentation.description || '',
              author: test.documentation.author || '',
              lastUpdated: test.documentation.lastUpdated || new Date().toISOString().split('T')[0],
              notes: test.documentation.notes || '',
              tags: Array.isArray(test.documentation.tags) ? test.documentation.tags : []
            };
            savedCount++;
          }
        });
        
        logDebug(`saveDocumentationToStorage: ${savedCount} Dokumente vorbereitet`);
        
        try {
          // Prüfen, ob localStorage verfügbar ist
          if (typeof localStorage === 'undefined') {
            throw new Error('localStorage ist nicht verfügbar');
          }
          
          // Prüfen, ob genug Speicherplatz vorhanden ist
          const jsonData = JSON.stringify(documentationData);
          logDebug(`Größe der zu speichernden Daten: ${jsonData.length} Zeichen`);
          
          localStorage.setItem('test_documentation', jsonData);
          logDebug(`saveDocumentationToStorage: ${savedCount} Dokumente erfolgreich gespeichert`); 
          
          // Erfolgsbestätigung für den Benutzer
          const saveStatus = document.getElementById('save-status');
          if (saveStatus) {
            saveStatus.textContent = `Dokumentation gespeichert (${savedCount} Tests)`;
            saveStatus.classList.remove('d-none');
            setTimeout(() => {
              saveStatus.classList.add('d-none');
            }, 3000);
          }
        } catch (e) {
          logDebug('Fehler beim Speichern der Dokumentation:', e);
          
          // Benutzer über den Fehler informieren
          const saveStatus = document.getElementById('save-status');
          if (saveStatus) {
            saveStatus.textContent = `Fehler beim Speichern: ${e.message}`;
            saveStatus.classList.remove('d-none');
            saveStatus.classList.remove('text-success');
            saveStatus.classList.add('text-danger');
            setTimeout(() => {
              saveStatus.classList.add('d-none');
              saveStatus.classList.add('text-success');
              saveStatus.classList.remove('text-danger');
            }, 5000);
          }
        }
      }
      
      /**
       * Zeigt die Metriken für einen Test an
       */
      function showTestMetrics(testId) {
        if (!testId) return;
        
        // Testdaten finden
        const test = testPortfolioData.find(t => (t.testId || t.id) === testId);
        if (!test) return;
        
        // Markieren der ausgewählten Zeile in der Tabelle
        document.querySelectorAll('.test-row').forEach(row => {
          row.classList.remove('table-active');
          if (row.getAttribute('data-test-id') === testId) {
            row.classList.add('table-active');
          }
        });
        
        // Metriken aktualisieren
        document.getElementById('metric-category').textContent = test.functionArea || test.area || 'Unbekannt';
        document.getElementById('metric-selectors').textContent = test.selectors ? test.selectors.length : '0';
        document.getElementById('metric-assertions').textContent = test.assertions ? test.assertions.length : '0';
        document.getElementById('metric-coverage').textContent = test.coverage ? `${test.coverage}%` : 'N/A';
        document.getElementById('metric-stability').textContent = test.stability ? `${test.stability}%` : 'N/A';
      }
      
      /**
       * Aktualisiert alle Charts des Test-Portfolios
       */
      function updatePortfolioCharts(data) {
        logDebug('updatePortfolioCharts: Starte Chart-Aktualisierung');
        
        if (!data) {
          logDebug('updatePortfolioCharts: Keine Daten vorhanden');
          return;
        }
        
        if (!Array.isArray(data)) {
          logDebug('updatePortfolioCharts: Daten sind kein Array', data);
          return;
        }
        
        logDebug(`updatePortfolioCharts: Aktualisiere Charts mit ${data.length} Tests`);
        
        try {
          // Prüfen, ob Chart.js geladen ist
          if (typeof Chart === 'undefined') {
            logDebug('Chart.js ist nicht geladen!');
            return;
          }
          
          // Dokumentationsstand-Chart
          updateDocumentationStatusChart(data);
          
          // Funktionsbereich-Verteilungs-Chart
          updateAreaDistributionChart(data);
          
          // Testtyp-Verteilungs-Chart
          updateTypeDistributionChart(data);
          
          logDebug('updatePortfolioCharts: Alle Charts erfolgreich aktualisiert');
        } catch (error) {
          logDebug('updatePortfolioCharts: Fehler bei der Chart-Aktualisierung', error);
        }
      }
      
      /**
       * Aktualisiert das Dokumentationsstand-Chart
       */
      function updateDocumentationStatusChart(data) {
        // Zählen der dokumentierten und undokumentierten Tests
        let documented = 0;
        let undocumented = 0;
        
        data.forEach(test => {
          if (test.documentation && test.documentation.exists) {
            documented++;
          } else {
            undocumented++;
          }
        });
        
        // Chart-Container abrufen
        const chartContainer = document.getElementById('documentation-status-chart-container');
        if (!chartContainer) return;
        
        // Prüfen, ob Chart.js vorhanden ist
        if (!window.Chart) {
          chartContainer.innerHTML = 'Chart.js wird benötigt, um Diagramme anzuzeigen.';
          return;
        }
        
        // Altes Chart zerstören, falls vorhanden
        if (documentationStatusChart) {
          documentationStatusChart.destroy();
        }
        
        // Canvas erstellen
        chartContainer.innerHTML = '<canvas></canvas>';
        const canvas = chartContainer.querySelector('canvas');
        
        try {
          // Neues Chart erstellen
          documentationStatusChart = new Chart(canvas, {
            type: 'doughnut',
            data: {
              labels: ['Dokumentiert', 'Undokumentiert'],
              datasets: [{
                data: [documented, undocumented],
                backgroundColor: ['#198754', '#dc3545'],
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const total = documented + undocumented;
                      const percent = Math.round((context.raw / total) * 100);
                      return `${context.label}: ${context.raw} (${percent}%)`;
                    }
                  }
                }
              }
            }
          });
        } catch (e) {
          console.error('Fehler beim Erstellen des Dokumentationsstand-Charts:', e);
          chartContainer.innerHTML = 'Fehler beim Erstellen des Charts.';
        }
      }
      
      /**
       * Aktualisiert das Funktionsbereich-Verteilungs-Chart
       */
      function updateAreaDistributionChart(data) {
        // Tests nach Funktionsbereichen gruppieren
        const areas = {};
        
        data.forEach(test => {
          const area = test.functionArea || test.area || 'Unbekannt';
          if (!areas[area]) {
            areas[area] = 0;
          }
          areas[area]++;
        });
        
        // Chart-Container abrufen
        const chartContainer = document.getElementById('area-distribution-chart-container');
        if (!chartContainer) return;
        
        // Prüfen, ob Chart.js vorhanden ist
        if (!window.Chart) {
          chartContainer.innerHTML = 'Chart.js wird benötigt, um Diagramme anzuzeigen.';
          return;
        }
        
        // Altes Chart zerstören, falls vorhanden
        if (areaDistributionChart) {
          areaDistributionChart.destroy();
        }
        
        // Canvas erstellen
        chartContainer.innerHTML = '<canvas></canvas>';
        const canvas = chartContainer.querySelector('canvas');
        
        // Farben generieren
        const backgroundColors = Object.keys(areas).map((_, index) => {
          const hue = (index * 137) % 360;
          return `hsla(${hue}, 70%, 60%, 0.7)`;
        });
        
        try {
          // Neues Chart erstellen
          areaDistributionChart = new Chart(canvas, {
            type: 'pie',
            data: {
              labels: Object.keys(areas),
              datasets: [{
                data: Object.values(areas),
                backgroundColor: backgroundColors,
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom',
                  labels: {
                    boxWidth: 12
                  }
                }
              }
            }
          });
        } catch (e) {
          console.error('Fehler beim Erstellen des Funktionsbereich-Charts:', e);
          chartContainer.innerHTML = 'Fehler beim Erstellen des Charts.';
        }
      }
      
      /**
       * Aktualisiert das Testtyp-Verteilungs-Chart
       */
      function updateTypeDistributionChart(data) {
        // Tests nach Typen gruppieren
        const types = {};
        
        data.forEach(test => {
          const type = test.testType || 'Unbekannt';
          if (!types[type]) {
            types[type] = 0;
          }
          types[type]++;
        });
        
        // Chart-Container abrufen
        const chartContainer = document.getElementById('type-distribution-chart-container');
        if (!chartContainer) return;
        
        // Prüfen, ob Chart.js vorhanden ist
        if (!window.Chart) {
          chartContainer.innerHTML = 'Chart.js wird benötigt, um Diagramme anzuzeigen.';
          return;
        }
        
        // Altes Chart zerstören, falls vorhanden
        if (typeDistributionChart) {
          typeDistributionChart.destroy();
        }
        
        // Canvas erstellen
        chartContainer.innerHTML = '<canvas></canvas>';
        const canvas = chartContainer.querySelector('canvas');
        
        // Standardfarben für Testtypen
        const typeColors = {
          'e2e': '#6610f2',
          'component': '#fd7e14',
          'unit': '#20c997',
          'integration': '#0dcaf0',
          'visual': '#d63384',
          'Unbekannt': '#6c757d'
        };
        
        try {
          // Neues Chart erstellen
          typeDistributionChart = new Chart(canvas, {
            type: 'bar',
            data: {
              labels: Object.keys(types),
              datasets: [{
                data: Object.values(types),
                backgroundColor: Object.keys(types).map(type => typeColors[type] || '#6c757d'),
                borderWidth: 1
              }]
            },
            options: {
              indexAxis: 'y',
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false
                }
              },
              scales: {
                x: {
                  beginAtZero: true,
                  ticks: {
                    precision: 0
                  }
                }
              }
            }
          });
        } catch (e) {
          console.error('Fehler beim Erstellen des Testtyp-Charts:', e);
          chartContainer.innerHTML = 'Fehler beim Erstellen des Charts.';
        }
      }
      
      /**
       * Exportiert das Test-Portfolio als CSV-Datei
       */
      function exportTestPortfolio() {
        if (!testPortfolioData || testPortfolioData.length === 0) {
          alert('Keine Testdaten vorhanden, die exportiert werden könnten.');
          return;
        }
        
        // CSV-Header erstellen
        let csv = 'Test-Name,Funktionsbereich,Testtyp,Qualitätsscore,Dokumentiert,Beschreibung,Autor,Zuletzt aktualisiert,Hinweise,Tags\n';
        
        // Zeilen für jeden Test hinzufügen
        testPortfolioData.forEach(test => {
          const testName = (test.testName || test.name || 'Unbenannter Test').replace(/"/g, '""');
          const area = (test.functionArea || test.area || 'Unbekannt').replace(/"/g, '""');
          const type = (test.testType || 'Unbekannt').replace(/"/g, '""');
          const quality = test.qualityScore || 0;
          const isDocumented = test.documentation && test.documentation.exists ? 'Ja' : 'Nein';
          const description = test.documentation ? (test.documentation.description || '').replace(/"/g, '""') : '';
          const author = test.documentation ? (test.documentation.author || '').replace(/"/g, '""') : '';
          const lastUpdated = test.documentation ? (test.documentation.lastUpdated || '') : '';
          const notes = test.documentation ? (test.documentation.notes || '').replace(/"/g, '""') : '';
          const tags = test.documentation && test.documentation.tags ? test.documentation.tags.join(', ').replace(/"/g, '""') : '';
          
          csv += `"${testName}","${area}","${type}",${quality},"${isDocumented}","${description}","${author}","${lastUpdated}","${notes}","${tags}"\n`;
        });
        
        // CSV-Datei erstellen und herunterladen
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `test-portfolio-${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      /**
       * Generiert einen ausführlichen PDF-Bericht über das Test-Portfolio
       */
      function generatePortfolioReport() {
        alert('Die Berichtsgenerierung wird in einer zukünftigen Version implementiert.');
      }
    });
  </script>
  
  <!-- Neu: Test-Konfigurationsbereich -->
  <div class="modal fade" id="testConfigModal" tabindex="-1" aria-labelledby="testConfigModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="testConfigModalLabel">Test-Konfiguration</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="testTypeSelect" class="form-label">Test-Typ:</label>
            <select id="testTypeSelect" class="form-select">
              <option value="ux">UX-Test</option>
              <option value="accessibility">Accessibility-Test</option>
              <option value="performance">Performance-Test</option>
              <option value="combined">Kombinierter Test</option>
              <option value="end-to-end">End-to-End-Test</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="testUrlInput" class="form-label">URL:</label>
            <input type="text" class="form-control" id="testUrlInput" value="http://localhost:4321/">
            <div class="form-text">URL der zu testenden Seite.</div>
          </div>
          <div class="mb-3">
            <label for="promptTemplateSelect" class="form-label">Prompt-Vorlage auswählen:</label>
            <select class="form-select" id="promptTemplateSelect">
              <option value="custom" selected>Benutzerdefiniertes Prompt</option>
              <option value="navigation">Navigation & Struktur testen</option>
              <option value="forms">Formulare & Eingaben testen</option>
              <option value="accessibility">Barrierefreiheit testen</option>
              <option value="performance">Performance & Ladezeiten testen</option>
              <option value="mobile">Mobile Benutzerfreundlichkeit testen</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="testPromptTextarea" class="form-label">Benutzerdefiniertes Test-Prompt (optional):</label>
            <textarea class="form-control" id="testPromptTextarea" rows="3" placeholder="Beschreiben Sie die spezifische Testaufgabe..."></textarea>
            <small class="form-text text-muted">Geben Sie eine detaillierte Aufgabenbeschreibung ein, um den Test-Agent zu steuern.</small>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
          <button type="button" class="btn btn-primary" id="startTestBtn">Test starten</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Chart.js für Diagramme -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Migrierte TypeScript-Module (kompiliert) -->
  <script src="/js/dist/success-rate-view.js"></script>
  <script src="/js/dist/flakiness-view.js"></script>
  <script src="/js/dist/logs.js"></script>
  <script src="/js/dist/test-analysis.js"></script>
  <script src="/js/dist/dashboard-init.js"></script>
</body>
</html>